<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>搭建博客杂谈</title>
      <link href="/2022/05/11/da-jian-bo-ke-za-tan/"/>
      <url>/2022/05/11/da-jian-bo-ke-za-tan/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建博客杂谈"><a href="#搭建博客杂谈" class="headerlink" title="搭建博客杂谈"></a>搭建博客杂谈</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>坦白说，这次注册的域名的命名确实有玩梗的成分在：<a href="https://flying2the.top/">https://flying2the.top</a> （当然也是方便记忆了）</p><h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p>本地安装<a href="https://nodejs.org/en/">Node.js (nodejs.org)</a></p><p>进入本地终端，使用下列命令检查是否安装成功</p><pre class=" language-shell"><code class="language-shell">node -vnpm -vnpm config set registry https://registry.npm.taobao.org #添加国内镜像源</code></pre><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>本地安装<a href="https://git-scm.com/downloads">Git - Downloads (git-scm.com)</a></p><p>进入终端，检验git是否正确安装：</p><pre class=" language-shell"><code class="language-shell">git --version</code></pre><h2 id="注册GitHub账号，创建一个新repo"><a href="#注册GitHub账号，创建一个新repo" class="headerlink" title="注册GitHub账号，创建一个新repo"></a>注册GitHub账号，创建一个新repo</h2><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/repo.png"></p><p>选择GitHub pages主题</p><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/theme.png"></p><h2 id="本地安装hexo"><a href="#本地安装hexo" class="headerlink" title="本地安装hexo"></a>本地安装hexo</h2><p>新建一个blog文件夹，该目录下右键点击<code>Git Bash Here</code>，打开git的shell，输入<code>npm i hexo-cli -g</code>安装Hexo，</p><p>安装完后输入<code>hexo -v</code>验证是否安装成功，输入<code>hexo init</code>初始化文件夹，接着输入<code>npm install</code>安装必备的组件。</p><p>最常用的几个命令：</p><pre class=" language-shell"><code class="language-shell">hexo g #本地buildhexo s #本地启动服务，可通过本地的4000端口预览hexo d #deploy到GitHub服务器上</code></pre><h2 id="本地生成密钥"><a href="#本地生成密钥" class="headerlink" title="本地生成密钥"></a>本地生成密钥</h2><p>注册自有的Github账号，右键打开git bash，然后输入下面命令：</p><pre class=" language-shell"><code class="language-shell">git config --global user.name "GuoYu2022"git config --global user.email "yg9655@icloud.com"</code></pre><p>然后生成密钥SSH key：</p><pre class=" language-shell"><code class="language-shell">ssh-keygen -t rsa -C "yg9655@icloud.com"</code></pre><p>GitHub的设置里面新建一个SSH，在bash中输入</p><pre class=" language-shell"><code class="language-shell">cat ~/.ssh/id_rsa.pub</code></pre><p>将读取出的密钥信息复制到GitHub的SSH里面</p><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-05-11%20143240.png"></p><p>输入<code>ssh -T git@github.com</code>，如果出现用户名，说明已经成功</p><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/1.png"></p><h2 id="执行Hexo-d报错Spawn-failed，-以及OpenSSL-SSL-read-Connection-was-reset-errno-10054"><a href="#执行Hexo-d报错Spawn-failed，-以及OpenSSL-SSL-read-Connection-was-reset-errno-10054" class="headerlink" title="执行Hexo d报错Spawn failed， 以及OpenSSL SSL_read: Connection was reset, errno 10054"></a><font color="red"><strong>执行Hexo d报错Spawn failed， 以及OpenSSL SSL_read: Connection was reset, errno 10054</strong></font></h2><p>在部署时报了这样的错误，解决方法如下</p><pre class=" language-shell"><code class="language-shell">ssh git@github.com #首先检测SSH密钥是否有效hexo config deploy.repository git@github.com:GuoYu2022/GuoYu2022.github.io.git # 参考这一句解决hexo config deploy.repository git@github.com:[yourgitname]/[yourgitname].github.io.githexo d #最后就可以deploy了</code></pre><h2 id="对于每次部署新博文到GitHub上时，重定向域名失效问题的解决方法"><a href="#对于每次部署新博文到GitHub上时，重定向域名失效问题的解决方法" class="headerlink" title="对于每次部署新博文到GitHub上时，重定向域名失效问题的解决方法"></a><font color="red"><strong>对于每次部署新博文到GitHub上时，重定向域名失效问题的解决方法</strong></font></h2><p>首先需要确定GitHub仓库根目录下已有CNAME文件，在本地博客根目录文件夹下<strong>source</strong> 文件夹里新建一个CNAME文件（<font color="red"><strong>注意该文件没有后缀名</strong></font>），内容为你的域名<code>flying2the.top</code>（<font color="red"><strong>这里不需要写www或者https</strong></font>），然后hexo g -d</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>R语言数据处理基础</title>
      <link href="/2022/05/11/r-yu-yan-shu-ju-chu-li-ji-chu/"/>
      <url>/2022/05/11/r-yu-yan-shu-ju-chu-li-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>在 R 中有许多用于数据框基本操作的内置函数，比如 transform()、rbind()、cbind()等函数，都是基于base 包的。base 包是安装 R 时会自带的包，无须加载包就可以直接使用。除此之外，还有如下 几种常用的数据处理的包。</p><p>（1）dplyr 包：dplyr 包是 Hadley Wickham（ggplot2 包的作者）的杰作，他将原本 plyr 包中的 ddply()等函数进一步分离强化， 专注接受 dataframe 对象，大幅提高了速度，并且提供了更稳健地与其他数据库对象间的接口。该包常用的函数包括：<strong>变量筛选函数 select()、记录筛选函数 filter()、排序函数 arrange()、变形（计算） 函数 mutate()、汇总函数 summarize()、分组函数 group_by()、随机抽样函数 sample_n()和 sample_frac()， 以及多步操作连接符 %&gt;%等。</strong></p><p>（2）tidyr 包：在具体应用中，tidyr 包经常与 dplyr 包共同使用，目前渐有取代 reshape2 包之势， 是值得关注的一个 R 包。在 tidyr 包中，有 4 个常用的函数，分别是：<strong>gather()函数用于将宽数据转换为长数据；spread()函数用于将长数据转换为宽数据；unite()函数用于将多列数据合并为一列数据； separate()函数用于将一列数分离为多列数。</strong></p><p>（3）reshape2 包：reshape2 包是由 Hadley Wickham 开发的<strong>用于数据重构的包</strong>，主要功能函数为 melt()、cast()，其实现了长数据和宽数据之间的转换，包中还包含 add_margin()等其他函数和 french_fries（三种不同的油对薯条口感的影响）等数据集。</p><p>（4）tidyverse 包：tidyverse 是由 Hadley Wickham 于 2017 年创建的 R 包的集合，它“分享整洁数据的基础设计理念、语法和数据结构”。核心软件包是 ggplot2、dplyr、tidyr、readr、purrr、tibble、 stringr 和 forcats，它们提供了建模、转换和可视化数据的功能。更多内容可以见他出版的新书 R for  Data Science。其中，readr 包用于读取数据，tidyr 包用于整理数据，dplyr 包用于数据转换，ggplot2 包用于数据可视化，purrr 包用于函数式编程。大家如对此有兴趣，可以更加深入地学习。</p><h2 id="这里简单介绍一下一维表和二维表的区别"><a href="#这里简单介绍一下一维表和二维表的区别" class="headerlink" title="这里简单介绍一下一维表和二维表的区别"></a>这里简单介绍一下一维表和二维表的区别</h2><p>一维数据列表就是由字段和记录组成的表格。一般来说字段在首行， 下面每一行是一条记录。一维数据列表通常可以作为数据分析的数据源， 每一行代表完整的一条数据记录，所以可以很方便地进行数据的录入、 更新、查询、匹配等。<strong>仅需通过单行就能确定数值的，被称为一维表。</strong></p><p><img src="https://pic1.zhimg.com/80/v2-066d0eb84c4abf113c6f32f6e960e55c_720w.jpg"></p><p>为了方便浏览打印美观，很多人会把重复姓名合并单元格，如下图（合并单元格只是格式美观，对数据清洗反而是一大障碍，会耗费额外时间精力）</p><p><img src="https://pic2.zhimg.com/80/v2-bb0b2f10101044f57348c7d6a4038af1_720w.png"></p><p>二维数据列表就是行和列都有字段，它们相交的位置是数值的表格。 这类表格一般是由分类汇总得来的，既有分类，又有汇总，所以是通过 一维数据列表加工处理过的，通常用于呈现展示。<strong>确定一个数值，必须通过行列两个条件去定位，这是二维表最显著的特征</strong>，如下图：</p><p><img src="https://pic1.zhimg.com/80/v2-4939d593f8d439fa57aee14ab2fd68e0_720w.jpg"></p><p>最早接触一维表的，是那些数据库从业者，因为一维表大都是系统自动生成的。但凡从数据库系统里导出来的表，不管是XLS还是CSV，都是一维表样式。<strong>换句话说，一维表是符合数据库设计规范的，需要行和列来定位数值的，就是二维表；仅靠单行就能锁定全部信息的，就是一维表</strong>，一维表、二维表可以相互转换。一维转二维用透视表，反之用逆透视。</p><h2 id="2-1表格的转换"><a href="#2-1表格的转换" class="headerlink" title="2.1表格的转换"></a>2.1表格的转换</h2><h3 id="2-1-1表格的变换"><a href="#2-1-1表格的变换" class="headerlink" title="2.1.1表格的变换"></a>2.1.1表格的变换</h3><p>在使用 R ggplot2 绘图时，通常使用一维数据列表的数据框。但是如果导入的数据表格是二维数据列表，我们则需要使用 reshape2 包的 melt()函数或者 tidyr 包的 gather()函数，可以<strong>将二维数据列表的数据框转换成一维数据列表，首先构造数据框：</strong></p><pre class=" language-R"><code class="language-R">df<- data.frame(x=c('A','B','C'),'2010'=c(1,3,4),'2011'=c(3,5,2),check.names=FALSE)</code></pre><p>（1）将宽数据转换为长数据，将多行聚集成列，从而将二维数据列表变成一维数据列表：</p><pre class=" language-R"><code class="language-R">df_melt<- reshape2::melt(df, id.vars="x",variable.name="year",value.name = "value")df_gather<- tidyr:: gather(df,year,value,-x#以上两句实现相同的效果</code></pre><p>其中，id.vars (“x”)表示由标识变量构成的向量，用于标识观测的变量；variable.name (“year”)表示用于保存原始变量名的变量的名称；value.name(“value”)表示用于保存原始值的名称。</p><p>（2）将长数据转换为宽数据，将一列根据变量展开为多行，从而将一维数据列表变成二维数据列表：</p><pre class=" language-R"><code class="language-R">df_dcast<- reshape2:: dcast (df_melt,x~year,value.var="value")df_spread <- tidyr::spread(df_gather,year, value)#以上两句实现相同的效果</code></pre><p>其中，dcast 借助于公式来描述数据的形状 id.vars~variable.name，左边参数表示 id.vars (“x”)， 而右边的参数表示 variable.name (“year”)。</p><p><font color="purple">&nbsp;<strong>此处插入图片</strong></font></p><h3 id="2-1-2变量的变换"><a href="#2-1-2变量的变换" class="headerlink" title="2.1.2变量的变换"></a>2.1.2变量的变换</h3><p>有时候，需要对数据框中某列的每个元素都进行运算处理，从而产生并添加新的列。可以使用 R 内置函数 transform()为原数据框添加新的列，可以改变原变量列的值， 也可以赋值 NULL 删除列变量：</p><pre class=" language-R"><code class="language-R">dat1<-transform(df_melt, value2=value*2)</code></pre><p>可以结合向量化的条件语句 ifelse()进行复杂运算。另外，dplyr 包的 mutate()函数也能实现与 transform()函数相同的功能。但是 mutate()函数很好地解决了 transform()函数不能解决的 问题，即 mutate()函数允许新列对刚刚建立起来的列进行计算。</p><pre class=" language-R"><code class="language-R">dat2<- transform(df_melt, value2=ifelse(year=="2011", value*2, value))dat2<- dplyr:: mutate(df_melt, value2=ifelse(year=="2011", value*2, value)#将2011年的数据翻倍</code></pre><p><font color="purple"> <strong>此处插入图片</strong></font></p><h3 id="2-1-3表格的排序"><a href="#2-1-3表格的排序" class="headerlink" title="2.1.3表格的排序"></a>2.1.3表格的排序</h3><p>此外可以使用 sort()函数对向量进行排序处理。对于数据框，我们可使用 dplyr 包的 arrange()函数，根据数据框的某列数值对整个表排序。其中 desc(value)表示根据 df 的 value 列做降序处理，如 dat_arrange2 数据框所示。</p><pre class=" language-R"><code class="language-R">dat_arrange1<- dplyr:: arrange (df_melt, value)dat_arrange2<- dplyr:: arrange (df_melt, desc(value))</code></pre><p><font color="purple"> <strong>此处插入图片</strong></font></p><h2 id="2-2表格的整理"><a href="#2-2表格的整理" class="headerlink" title="2.2表格的整理"></a>2.2表格的整理</h2><h3 id="2-2-1表格的拼接"><a href="#2-2-1表格的拼接" class="headerlink" title="2.2.1表格的拼接"></a>2.2.1表格的拼接</h3><p>需要在已有数据框的基础上添加新的行/列，或者横向/纵向添加另外一个表格。此时需要使用R内置函数 cbind()和 rbind()，或者 dplyr 包的 bind_cols()函数和 bind_rows()函数实现该功能。先构造 3 个数据框如下：</p><pre class=" language-R"><code class="language-R">df1<-data.frame(x= c("a","b","c"), y=1:3)df2<- data.frame(z= c("B","D","H"), g =c(2,5,3))df3<- data.frame(x= c("g","d"), y =c(2,5))</code></pre><p>（1）数据框添加列或者横向添加表格：</p><pre class=" language-R"><code class="language-R">dat_cbind<-cbind(df1,df2) </code></pre><p>（2）数据框添加行或者纵向添加表格：</p><pre class=" language-R"><code class="language-R">dat_rbind<-rbind(df1,df3)</code></pre><p><font color="purple"> <strong>此处插入图片</strong></font></p><h3 id="2-2-2表格的融合"><a href="#2-2-2表格的融合" class="headerlink" title="2.2.2表格的融合"></a>2.2.2表格的融合</h3><p>有时，两个数据框并没有很好地保持一致，不能简单地使用 cbind()函数或 rbind()函数直接拼接。所以它们<strong>需要一个共同的列（common key）作为融合的依据。</strong>在表格的融合中，最常用的函数是R内置函数 merge()和 dplyr 包的*_join()系列函数。我们首先构造 4 个数据框，如下：</p><pre class=" language-R"><code class="language-R">df1<-data.frame(x= c("a","b","c"), y=1:3)df2<- data.frame(x= c("a","b","d"), z =c(2,5,3))df3<- data.frame(g= c("a","b","d"), z =c(2,5,3))df4<- data.frame(x= c("a","b","d"), y=c(1,4,2),z =c(2,5,3))</code></pre><p><font color="purple"> <strong>此处插入图片</strong></font></p><p>（1）merge()函数</p><p>其优势在于对每个数据框可以指定不同的匹配列名；缺点在于运行速度比较慢。其中，by.x 是指左边数据框的匹配列，by.y 是指右边数据框的匹配列。</p><pre class=" language-R"><code class="language-R">dat_merge1 <-merge(df1,df2,by="x", all = TRUE) dat_merge2 <-merge(df1,df3,by.x="x",by.y="g") dat_merge3 <-merge(df1,df4,by=c("x","y"), all = TRUE) </code></pre><p>效果如下所示</p><p><font color="purple"> <strong>此处插入图片</strong></font></p><p>（2）*_join()系列函数</p><p>dplyr 包提供了 left_join()、 right_join()、inner_join()和 full_ join()四个函数，可以实现不同的表格融合效果。其中，full_ join()函数主要用来生成两个集合的并集；inner_join()函数通常用来生成有效的数据；left_join()函数和 right_join()函数使用的场景偏少。另外，两个表格融合时会用 NA（缺失 值）代替不存在的值。</p><ul><li>只保留左表的所有数据：</li></ul><pre class=" language-R"><code class="language-R">dat_join1 <-dplyr::left_join (x=df1,y=df2,by="x")</code></pre><ul><li>只保留右表的所有数据：</li></ul><pre class=" language-R"><code class="language-R">dat_join2 <-dplyr::right_join (x=df1,y=df2,by= "x")</code></pre><ul><li>只保留两个表中公共部分的信息：</li></ul><pre class=" language-R"><code class="language-R">dat_join3 <-dplyr::inner_join (x=df1,y=df2,by="x")</code></pre><ul><li>保留两个表的所有信息：</li></ul><pre class=" language-R"><code class="language-R">dat_join4 <-dplyr:: full_join(x=df1,y=df2,by="x")</code></pre><p><font color="purple"> <strong>此处插入图片</strong></font></p><ul><li>by=c(“x”,”y”)表示多列匹配：</li></ul><pre class=" language-R"><code class="language-R">dat_join5 <-dplyr::left_join (x=df1,y=df4,by= c("x","y"))</code></pre><ul><li>by=c(“x”=”g”)可以根据两个表的不同列名合并：</li></ul><pre class=" language-R"><code class="language-R">dat_join6 <-dplyr::left_join (x=df1,y=df3,by= c("x"="g"))</code></pre><ul><li>如果与表合并的过程中遇到有一列在两个表中同名，但是值不同，合并的时候又都想保留下来，就可以用 suffix 给每个表的重复列名增加后缀：</li></ul><pre class=" language-R"><code class="language-R">dat_join7<-dplyr::left_join (x=df1,y=df4,by="x", suffix=c(".1",".2"))</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>R语言实战</title>
      <link href="/2022/05/11/r-yu-yan-shi-zhan/"/>
      <url>/2022/05/11/r-yu-yan-shi-zhan/</url>
      
        <content type="html"><![CDATA[<h2 id="一、R语言编程与绘图基础"><a href="#一、R语言编程与绘图基础" class="headerlink" title="一、R语言编程与绘图基础"></a>一、R语言编程与绘图基础</h2><h3 id="1、R语言编程基础"><a href="#1、R语言编程基础" class="headerlink" title="1、R语言编程基础"></a>1、R语言编程基础</h3><h4 id="1-1数据类型"><a href="#1-1数据类型" class="headerlink" title="1.1数据类型"></a>1.1数据类型</h4><p>R中常见的数据类型为数值型（numeric）、字符型（character）、日期型（date）、逻辑型（logical），变量的数据类型都可以用class()函数查看</p><ul><li><p>数值型</p><pre class=" language-R"><code class="language-R">a<- 1;is.numeric(a)#输出判定a是否为数值型：TRUE</code></pre></li><li><p>字符型</p><pre class=" language-R"><code class="language-R">b<- "peter"; nchar(b)#输出字符串的长度</code></pre></li><li><p>日期型</p><p>最常用的日期型数据类型是Date（进存储日期）和POSIXct（同时存储日期和时间）</p><pre class=" language-R"><code class="language-R">c<-as.Date("2012-06-12");class(c)#输出c的类型为Dated<-as.POSIXct（"2012-06-12 17:32"）; class(d) #输出 d 的数据类型为："POSIXct" "POSIXt"</code></pre></li><li><p>逻辑型</p><pre class=" language-R"><code class="language-R">e<-TRUE, f<-FALSE</code></pre><p>其中，在处理时序数据时，我们需要处理日期型数据，往往需要使用 as.Date()函数将读入的数据从数值型转换成日期型，有时候还需要进一步提取日期型数据的年、月、周等数据信息。此时我 们需要使用 as.numeric()函数或者 as.integer()函数将日期型数据转换成数值型。其中，strftime(x, format  = “”)函数可以定义日期型数据的格式，比如 strftime(c, ‘%Y’)表示只显示年份。</p><pre class=" language-R"><code class="language-R">c_Year<- as.integer(strftime(c, '%Y')) #输出年份：2012 c_month <- as.integer(strftime(c, '%m')) #输出月份：6 c_week<- as.integer(strftime(c, '%W')) #输出周数：24</code></pre></li></ul><h4 id="1-2数据结构"><a href="#1-2数据结构" class="headerlink" title="1.2数据结构"></a>1.2数据结构</h4><p>常见的数据结构包括：<strong>向量（vector）</strong>、<strong>数据框（data.frame）</strong>、<strong>矩阵（matrix）</strong>、<strong>列表（list）</strong>和<strong>数组（array）</strong>。其中，矩阵是将数据用行和列排列的长方形表格，<strong>矩阵是二维数组，<em>其单元必须是相同的数据类型</em></strong>，通常用列来表示不同的变量，用行表示各个对象；<strong>数组可以看作是带有多个下标的类型 相同的元素的集合</strong>；列表是一个对象的有序集合构成的对象，列表中包含的对象又称为它的分量 （component），分量可以是不同的模式或（和）类型。我们在本书的<strong>数据可视化中，比较常用的是向量（因子属于特殊的向量）和数据框</strong>，所以我们重点介绍这两种类型的数据结构，还将介绍与数据可视化密切相关的函数。</p><h5 id="1-2-1向量"><a href="#1-2-1向量" class="headerlink" title="1.2.1向量"></a>1.2.1向量</h5><p>向量是用于存储数值型、字符型或逻辑型数据的一维数组。执行组合功能的函数 c()可用来创建 向量（c 代表合并：combine）。值得注意的是，<strong>单个向量中的数据类型是固定的</strong>，比如数值型向量中的元素就必须全为向量。向量是 R 语言中最基本的数据结构, 其他类型的数据结构都可以由向量构 成。最常见的向量有三种类型：数值型、字符型、逻辑型。</p><p><strong>（1）向量的创建</strong></p><p>向量的创建有多种方法，我们既可以手动输入，使用函数 c()创建向量；也可以使用现有的函数 创建向量，比如 seq()、rep()等函数</p><table><thead><tr><th align="center">输入</th><th align="center">输出</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">c(2,4,6)</td><td align="center">2 4 6</td><td align="center">将元素连接成向量</td></tr><tr><td align="center">2:6</td><td align="center">2 3 4 5 6</td><td align="center">等差整数数列</td></tr><tr><td align="center">seq(2, 3, by=0.5)</td><td align="center">2.0 2.5 3.0</td><td align="center">步长为 0.5 的等差数列</td></tr><tr><td align="center">rep(1:2, times=3)</td><td align="center">1 2 1 2 1 2</td><td align="center">将一个向量重复 3 次</td></tr><tr><td align="center">rep(1:2, each=3)</td><td align="center">1 1 1 2 2 2</td><td align="center">将一个向量中的每个元素重复 3 次</td></tr><tr><td align="center">rnorm(3, mean = 0, sd = 3)</td><td align="center">0.3823209 1.3203584 3.1263230</td><td align="center">均值为 0、标准差为 3 的正态分布</td></tr><tr><td align="center">runif(3, min = 0, max = 1)</td><td align="center">0.9552905 0.6813195 0.4527798</td><td align="center">最大值为 1、最小值为 0 的均匀分布</td></tr><tr><td align="center">sample(c(“A”,”B”,”C”), 4, replace=TRUE)</td><td align="center">“A” “A” “A” “B”</td><td align="center">从一个向量中随机抽取</td></tr></tbody></table><p><strong>（2）向量的处理</strong></p><ul><li><p>向量的排序</p><p>很多时候我们需要先对数据进行降序处理，再展示数据 。 sort() 函数可以实现对向量的排序处理，index.return=TRUE，表示返回排序的索引；decreasing = TRUE，表示降序处理。</p><pre class=" language-R"><code class="language-R">Vec<-c(1,4,3,5,2)order<-sort(Vec, index.return=TRUE,decreasing = TRUE)输出结果为：$x 为[5 4 3 2 1]，$ix 为[4 2 3 5 1]</code></pre></li><li><p>向量的唯一值</p><p>unique()函数主要是返回一个删除了重复元素或行的向量、数据框或数组。在需要对数据框根据某列进行分组运算时，需要使用该函数先获取类别总数。</p><pre class=" language-R"><code class="language-R">Vec<-c("peter","jack","peter","jack","eelin")Uni<-unique(Vec) #输出："peter", "jack", "eelin"</code></pre></li><li><p>连续向量的离散化</p><p>有时需要把连续型变量转换为离散型变量， 这种转换的过程就是<strong>数据离散化</strong>，<strong>分箱</strong>就是离散化常用的一种方法。数据离散化最简单的方法就是使用 cut()函数自定义离散区间，从而对数据进行离散处理。</p><pre class=" language-R"><code class="language-R">Num_Vector<- c(10, 5, 4, 7, 6, 1, 4, 8, 8, 5)Cut_Vector<-cut(Num_Vector,breaks=c(0,3,6,9,11), labels=c("0~3", "3~6", "6~9", ">9"), right = TRUE)#输出结果为因子向量：>9, 3~6, 3~6, 6~9, 3~6, 0~3, 3~6, 6~9, 6~9, 3~6；其水平 Levels 为: 0~3, 3~6, 6~9, >9</code></pre></li></ul><p><strong>（3）向量的索引</strong></p><p>向量是多个元素的集合，当我们只需要指定或者说提取该向量中的某个元素时，就可以使用向量的索引（indexing）。向量元素有三种基本类型的向量索引：<strong>整数型</strong>，索引的是元素位置；<strong>字符型</strong>， 索引的是名称属性；<strong>逻辑型</strong>，索引的是相同长度的逻辑向量对应的逻辑值为真的元素。</p><pre class=" language-R"><code class="language-R">x<-c(1,4,3,5,2)</code></pre><ul><li>整数型索引，选择某个或多个元素：x[2]; x[-2]; x[2:4]; x[c(1,4)]</li><li>逻辑型索引，逻辑运算选择元素：x[x&gt;2]; x[x==1]; x[x&lt;=5]</li></ul><h6 id="1-2-2因子"><a href="#1-2-2因子" class="headerlink" title="1.2.2因子"></a>1.2.2因子</h6><p>因子（factor）是 R 语言中许多强大运算的基础，包括许多针对表格数据的运算，可分为类别型变量和有序型变量。因子可以看成是<strong>包含了额外信息的向量</strong>，这额外的信息就是不同的类别，称之为水平（level）。因子在 R 中非常重要，因为它决定了数据的分析方式，以及如何进行视觉呈现。</p><p><strong>（1）因子的创建</strong></p><p>一个因子不仅包括分类变量本身，还包括变量不同的可能水平（即使它们在数据中不出现）。因 子函数 factor()用下面的选项创建一个因子。对于字符型向量，因子的水平默认依字母顺序创建:</p><pre class=" language-R"><code class="language-R">(Fair,Good, Ideal, Premium, Very Good)Cut<-c("Fair","Good","Very Good","Premium","Ideal") Cut_Facor1<-as.factor(Cut)#以下为输出结果#[1] Fair      Good      Very Good Premium   Ideal    #Levels: Fair Good Ideal Premium Very Good</code></pre><p><strong>（2）水平的更改</strong></p><p>可以指定 levels 选项来覆盖默认排序（按默认是以字母顺序排序）。更改因子向量的 levels 为(“Good”,”Fair”,”Very Good”,”Ideal”,”Premium”)，就需要使用 factor()函数更改 levels。</p><pre class=" language-R"><code class="language-R">Cut_Facor2<-factor(x=c("Fair","Good","Very Good","Premium","Ideal"), levels= c("Good","Fair","Very Good","Ideal","Premium"),  ordered=TRUE)#以下为输出结果#[1] Fair      Good      Very Good Premium   Ideal    #Levels: Good < Fair < Very Good < Ideal < Premium</code></pre><p><strong>（3）类型的转换</strong></p><p>数值型因子向量的类型变换。有时候需将数值型的因子向量重新转换成数值型向量，这时，需要使用 as.numeric(as.character())组合函数，而不能直接使用 as.numeric()函数。其中 as.character() 函数表示将向量变成字符型，as.numeric()函数表示将向量变成数值型。</p><pre class=" language-R"><code class="language-R">Num _Facor<-factor(x=c(1,3,5,2), levels= c(5,3,2,1), ordered=TRUE) Num_Vector1<-as.numeric(as.character(Num_Facor)) # 输出：1 3 5 2Num_Vector2<-as.numeric(Num_Facor) # 输出：4 2 1 3</code></pre><h5 id="1-2-3数据框"><a href="#1-2-3数据框" class="headerlink" title="1.2.3数据框"></a>1.2.3数据框</h5><p>数据框是 R 语言中的一种表格结构，数据框是由多个向量构成的，每个向量的长度相同。数据框类似矩阵，也是一个二维表结构。在统计学术语中，用行来表示观测（observation），用列来表示变量（variable）。</p><p><strong>（1）数据框的创建与查看</strong></p><p>创建数据框，最简单的方法就是，用同名的定义函数 data.frame()，输入每个变量的名称及对应的向量，每个向量的长度相同。一个数据框可能包含多个变量（向量），有时需要单独提取某个变量， 使用特殊的$符号来访问，由“数据框$变量名”构成。</p><ul><li>获取数据框的行数、列数和维数：nrow()、ncol()、dim()。</li><li>获取数据框的列名或行名：names()、rownames()、colnames()；重新定义列名：names(df)&lt;-c(“X”,  “Y”, “Z”)。</li><li>观察数据框的内容：view(df)、head(df, n=3)、tail(df)。</li></ul><p><strong>（2）空数据框的创建</strong></p><p>创建空数据框，在需要自己构造绘图的数据框数据信息时尤为重要。有时，在绘制复杂的数据图表的过程中，我们需要对现有数据进行插值、拟合等处理，这时需要使用空的数据框存储新的数据，最后使用新的数据框绘制图表。创建空的数据框主要有如下两种方法。</p><ul><li>创建一个名为 Df_Empty，包括两个变量（var_a 为 numeric 类型；var_b 为 character 类型）的 data.frame。但是注意：要加上 stringsAsFactors=FALSE，否则在后面逐行输入数据时，会因 为 var_b 的取值未经定义的 factor level 而报错。</li></ul><pre class=" language-R"><code class="language-R">Df_Empty1<- data.frame(var_a = numeric(),var_b = character(),stringsAsFactors=FALSE)</code></pre><ul><li><p>先使用矩阵创建空的数据框，同时通过 dimnames 设定数据框的列名。这个相比前一种方法 可以更快速地创建多列空数据框：</p><pre class=" language-R"><code class="language-R">Df_Empty2 <- data.frame(matrix(ncol=2, nrow=0,dimnames=list(c(),c("var_a","var_b"))))</code></pre></li></ul><h4 id="1-3数据属性"><a href="#1-3数据属性" class="headerlink" title="1.3数据属性"></a>1.3数据属性</h4><p>数据框作为 R 语言数据分析与可视化很常用的数据结构，常由多列不同数据属性的变量组成。 在我们实现数据可视化时，很有必要先了解这些变量的属性。Jiawei Han 等人的 Data mining: concepts and techniques根据数据属性取值的集合类型，将数据属性分成了三类：类别型、序数型和数值型。</p><h5 id="1-3-1类别型"><a href="#1-3-1类别型" class="headerlink" title="1.3.1类别型"></a>1.3.1类别型</h5><p>类别型属性（categorical attribute）是用于区分不同数据对象的符号或名称，而它们是没有顺序关系的，又包含多元类别和二元类别两种类型。对于多元类别，可以理解为购买服装时的不同服装名称，如衬衫、毛衣、T 恤、夹克等；对于二元类别，可以理解为购买服装时的不同性别，只有男士和女士两种性别分类。</p><h4 id="1-4数据的导入与输出"><a href="#1-4数据的导入与输出" class="headerlink" title="1.4数据的导入与输出"></a>1.4数据的导入与输出</h4><h4 id="1-5控制语句与函数编写"><a href="#1-5控制语句与函数编写" class="headerlink" title="1.5控制语句与函数编写"></a>1.5控制语句与函数编写</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/04/hello-world/"/>
      <url>/2022/05/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
