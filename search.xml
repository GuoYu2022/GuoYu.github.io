<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>R4DS读书笔记（第五章、探索性数据分析）</title>
      <link href="/2022/05/25/r4ds-du-shu-bi-ji-di-wu-zhang-tan-suo-xing-shu-ju-fen-xi/"/>
      <url>/2022/05/25/r4ds-du-shu-bi-ji-di-wu-zhang-tan-suo-xing-shu-ju-fen-xi/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>R4DS读书笔记（第三章、使用dplyr进行数据转换）</title>
      <link href="/2022/05/19/r4ds-du-shu-bi-ji-di-san-zhang-shi-yong-dplyr-jin-xing-shu-ju-zhuan-huan/"/>
      <url>/2022/05/19/r4ds-du-shu-bi-ji-di-san-zhang-shi-yong-dplyr-jin-xing-shu-ju-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>很多时候，数据集的数据格式并不符合我们的要求，有时需要创建新变量或者摘要统计量，此外还可能需要对变量进行重命名或者对观测值进行重排序，以便数据后期处理。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>这一部分重点介绍使用tidyverse中的另一个包：dplyr包，使用 nycflights13 包中的数据并借助ggplot2可视化来介绍dplyr包的用途。</p><pre class="line-numbers language-R"><code class="language-R">library(nycflights13)library(tidyverse) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>加载 tidyverse 时，注意输出的冲突信息，它会告诉你 dplyr 覆盖了基础 R 包中的哪些函数。如果想要在加载 dplyr 后使用这些函数的基础版本，那么需要使用完整名称：stats::filter() 和 stats::lag()。</p><h3 id="这里安装nycflights13包时出了问题"><a href="#这里安装nycflights13包时出了问题" class="headerlink" title="这里安装nycflights13包时出了问题"></a><font color="red">这里安装nycflights13包时出了问题</font></h3><p>起初解决这个问题的思路是设置Rstudio走代理，结果不行</p><p>然后设置Rstudio的包下载为国内镜像站，结果还是不行</p><p>于是大怒，直接谷歌到该包在CRAN上的具体下载地址，直接强制下载安装这个R包，这个方法比较暴力而且彻底，但是之后使用下载到本地的nycflights13 包时需要注明’nycflights13::’</p><pre class="line-numbers language-R"><code class="language-R">ggpack<-"https://cran.r-project.org/src/contrib/nycflights13_1.0.2.tar.gz"install.packages(ggpack, repos=NULL, type="source")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="nycflights13"><a href="#nycflights13" class="headerlink" title="nycflights13"></a>nycflights13</h3><p>使用 nycflights13::flights查询2013 年从纽约市出发的所有 336 776 次航班的信息</p><p>这个数据框的输出和我们以前用过的其他数据框有一点差别：只显示了前几行和适合屏幕宽度的几列。（要想看到整个数据集，可以使用 View(nycflights13::flights) 在 RStudio 查看器中打开数据集。）输出有差别是因为 flights 是一个 tibble。tibble 也是一种数据框， 只是进行了一些小小的修改，使其更适合在 tidyverse 中使用。</p><p>对于一些常用的变量类型：</p><ul><li>int表示整型变量</li><li>dbl表示双精度变量或实数</li><li>chr表示字符向量或字符串</li><li>dttm表示日期时间型变量</li><li>lgl表示逻辑型变量</li><li>fctr表示因子</li><li>date表示日期型变量</li></ul><h3 id="dplyr基础"><a href="#dplyr基础" class="headerlink" title="dplyr基础"></a>dplyr基础</h3><p>本章要学习dplyr的五个核心函数，可以解决数据处理中的绝大多数问题</p><ul><li>按值筛选观测（filter()）</li><li>对行进行重新排序（arrange()）</li><li>按名称选取变量（select()）</li><li>使用现有变量的函数创建新变量（mutate()）</li><li>将多个值总结为一个摘要统计量（summarize()）</li></ul><p>这些函数都可以和 group_by() 函数联合起来使用，group_by() 函数可以改变以上每个函数的作用范围，让其从在整个数据集上操作变为在每个分组上分别操作。</p><h3 id="使用filter-筛选行"><a href="#使用filter-筛选行" class="headerlink" title="使用filter()筛选行"></a>使用filter()筛选行</h3><p>filter() 函数可以基于观测的值筛选出一个观测子集。第一个参数是数据框名称，第二个参数以及随后的参数是用来筛选数据框的表达式。例如：</p><pre class="line-numbers language-R"><code class="language-R">dplyr::filter(nycflights13::flights,month==1,day==1)#筛选出1月1日的所有航班<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong><font color="red">注意这里要注明函数的包名出处，因为不同的包名包含相同名字的filter函数，因为是手动安装这个数据集包的，所以要带上nycflights13的名称</font></strong></p><p>执行上一句代码，dplyr 就会进行筛选操作，并返回一个新数据框。如需保存，则需赋值给一个对象。</p><pre class="line-numbers language-R"><code class="language-R">jan1 <- filter(flights, month == 1, day == 1)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><font color="red"><strong>如果想同时完成打印结果和赋值操作</strong></font></p><pre class="line-numbers language-R"><code class="language-R">(dec25 <- filter(flights, month == 12, day == 25))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>R 提供了一套标准的 比较运算符：&gt;、&gt;=、&lt;、&lt;=、!=（不等于）和 ==（等于）</p><p>1、注意比较时，应当使用==（等于）而不应该是=（赋值）</p><p>2、注意浮点数与整数的比较结果</p><pre class="line-numbers language-R"><code class="language-R">sqrt(2) ^ 2 == 2#> [1] FALSE1/49 * 49 == 1#> [1] FALSE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>3、比较浮点数是否相等时，不能使用 ==，而应该使用 near()</p><pre class="line-numbers language-R"><code class="language-R">near(sqrt(2) ^ 2, 2)#> [1] TRUEnear(1 / 49 * 49, 1)#> [1] TRUE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>filter() 中的多个参数是由“与”组合起来的：每个表达式都必须为真才能让一行观测包含在输出中。如果要实现其他类型的组合，你需要使用布尔运算符：&amp; 表示“与”、| 表示 “或”、! 表示“非”。下图给出了布尔运算的完整集合。</p><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-05-20%20154440.png"></p><p>找出 11 月或 12 月出发的所有航班：</p><pre><code>dplyr::filter(nycflights13::flights, month == 11 | month == 12)</code></pre><p><font color="red"><strong>注意这里不能写成month==11|12，这样返回的结果是一个布尔值，也就是TRUE（1），即filter是要搜寻1月份的数据。</strong></font></p><p>此外还有一种简写方式，x %in% y。这样会选取出 x 是 y 中的一个值时的所有行.</p><pre class="line-numbers language-R"><code class="language-R">nov_dec <- dplyr::filter(nycflights13::flights, month %in% c(11, 12))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以使用德摩根定律将复杂的筛选条件进行简化：!(x &amp; y) 等价于 !x | !y、!(x |  y) 等价于 !x &amp; !y。例如，如果想要找出延误时间（到达或出发）不多于 2 小时的航班， 那么使用以下两种筛选方式均可：</p><pre class="line-numbers language-R"><code class="language-R">dplyr::filter(nycflights13::flights, !(arr_delay > 120 | dep_delay > 120))dplyr::filter(nycflights13::flights, arr_delay <= 120, dep_delay <= 120)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h4><p>NA 表示未知的值，或称 NA（not available，不可用）。如果运算中包含了未知值，那么运算结果一般来说也是个未知值：</p><pre class="line-numbers language-R"><code class="language-R">NA > 5#> [1] NA10 == NA#> [1] NANA + 10#> [1] NANA / 2#> [1] NA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最令人费解的是以下这个结果：</p><pre class="line-numbers language-R"><code class="language-R">NA == NA#> [1] NA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们可以这么理解：</p><pre class="line-numbers language-R"><code class="language-R"># 令x为Mary的年龄。我们不知道她有多大。x <- NA# 令y为John的年龄。我们不知道他有多大。y <- NA# John和Mary的年龄是相同的吗？x == y#> [1] NA# 我们不知道！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果想要确定一个值是否为缺失值，可以使用 is.na() 函数：</p><pre class="line-numbers language-R"><code class="language-R">is.na(x)#> [1] TRUE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>filter() 只能筛选出条件为 TRUE 的行；它会排除那些条件为 FALSE 和 NA 的行。如果想保留缺失值，可以明确指出：</p><pre class="line-numbers language-R"><code class="language-R">df <- tibble(x = c(1, NA, 3))filter(df, x > 1)#> # A tibble: 1 × 1#> x#> <dbl>#> 1 3filter(df, is.na(x) | x > 1)#> # A tibble: 2 × 1#> x#> <dbl>#> 1 NA#> 2 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用arrange-排列行"><a href="#使用arrange-排列行" class="headerlink" title="使用arrange()排列行"></a>使用arrange()排列行</h3><p>arrange（）与filter（）工作方式类似，但arrange（）不是选择行，而是改变行的顺序。它接受一个数据框和一组作为排序依据的列名（或者更复杂的表达式）作为参数。 如果列名不只一个，那么就使用后面的列在前面排序的基础上继续排序：</p><pre class="line-numbers language-R"><code class="language-R">dplyr::arrange(nycflights13::flights, year, month, day)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 desc() 可以按列进行降序排序：</p><pre class="line-numbers language-R"><code class="language-R">dplyr::arrange(nycflights13::flights, desc(arr_delay))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>缺失值总是排在最后：</p><pre class="line-numbers language-R"><code class="language-R">df <- dplyr::tibble(x = c(5, 2, NA))dplyr::arrange(df, x)#> # A tibble: 3 × 1#> x#> <dbl>#> 1 2#> 2 5#> 3 NA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-R"><code class="language-R">arrange(df, desc(x))#> # A tibble: 3 × 1#> x#> <dbl>#> 1 5#> 2 2#> 3 NA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用select（）选择列"><a href="#使用select（）选择列" class="headerlink" title="使用select（）选择列"></a>使用select（）选择列</h3><p>通过基于变量名的操作，select() 函数可以让你 快速生成一个有用的变量子集。</p><pre class="line-numbers language-R"><code class="language-R"># 按名称选择列dplyr::select(nycflights13::flights, year, month, day)# A tibble: 336,776 × 3    year month   day   <int> <int> <int> 1  2013     1     1 2  2013     1     1 3  2013     1     1 4  2013     1     1 5  2013     1     1 6  2013     1     1 7  2013     1     1 8  2013     1     1 9  2013     1     110  2013     1     1# … with 336,766 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-R"><code class="language-R"># 选择“year”和“day”之间的所有列（包括“year”和“day”）dplyr::select(nycflights13::flights, year:day)# A tibble: 336,776 × 3    year month   day   <int> <int> <int> 1  2013     1     1 2  2013     1     1 3  2013     1     1 4  2013     1     1 5  2013     1     1 6  2013     1     1 7  2013     1     1 8  2013     1     1 9  2013     1     110  2013     1     1# … with 336,766 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-R"><code class="language-R"># 选择不在“year”和“day”之间的所有列（不包括“year”和“day”）dplyr::select(nycflights13::flights, -(year:day))# A tibble: 336,776 × 16   dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier flight tail_num origin dest  air_time distance  hour minute time_hour                <int>          <int>     <dbl>    <int>          <int>     <dbl> <chr>    <int> <chr>   <chr>  <chr>    <dbl>    <dbl> <dbl>  <dbl> <dttm>              1      517            515         2      830            819        11 UA        1545 N14228  EWR    IAH        227     1400     5     15 2013-01-01 05:00:00 2      533            529         4      850            830        20 UA        1714 N24211  LGA    IAH        227     1416     5     29 2013-01-01 05:00:00 3      542            540         2      923            850        33 AA        1141 N619AA  JFK    MIA        160     1089     5     40 2013-01-01 05:00:00 4      544            545        -1     1004           1022       -18 B6         725 N804JB  JFK    BQN        183     1576     5     45 2013-01-01 05:00:00 5      554            600        -6      812            837       -25 DL         461 N668DN  LGA    ATL        116      762     6      0 2013-01-01 06:00:00 6      554            558        -4      740            728        12 UA        1696 N39463  EWR    ORD        150      719     5     58 2013-01-01 05:00:00 7      555            600        -5      913            854        19 B6         507 N516JB  EWR    FLL        158     1065     6      0 2013-01-01 06:00:00 8      557            600        -3      709            723       -14 EV        5708 N829AS  LGA    IAD         53      229     6      0 2013-01-01 06:00:00 9      557            600        -3      838            846        -8 B6          79 N593JB  JFK    MCO        140      944     6      0 2013-01-01 06:00:0010      558            600        -2      753            745         8 AA         301 N3ALAA  LGA    ORD        138      733     6      0 2013-01-01 06:00:00# … with 336,766 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 select () 函数中还可以使用一些辅助函数。</p><ul><li><p>starts_with(“abc”)：匹配以“abc”开头的名称。 </p></li><li><p>ends_with(“xyz”)：匹配以“xyz”结尾的名称。</p></li><li><p>contains(“ijk”)：匹配包含“ijk”的名称。 </p></li><li><p>matches(“(.)\1”)：选择匹配正则表达式的那些变量。这个正则表达式会匹配名称中有重复字符的变量。后面会介绍正则表达式的知识。 </p></li><li><p>num_range(“x”, 1:3)：匹配 x1、x2 和 x3。</p></li></ul><p>举个栗子：</p><pre class="line-numbers language-R"><code class="language-R">dplyr::select(nycflights13::flights,contains("time"))# A tibble: 336,776 × 6   dep_time sched_dep_time arr_time sched_arr_time air_time time_hour                <int>          <int>    <int>          <int>    <dbl> <dttm>              1      517            515      830            819      227 2013-01-01 05:00:00 2      533            529      850            830      227 2013-01-01 05:00:00 3      542            540      923            850      160 2013-01-01 05:00:00 4      544            545     1004           1022      183 2013-01-01 05:00:00 5      554            600      812            837      116 2013-01-01 06:00:00 6      554            558      740            728      150 2013-01-01 05:00:00 7      555            600      913            854      158 2013-01-01 06:00:00 8      557            600      709            723       53 2013-01-01 06:00:00 9      557            600      838            846      140 2013-01-01 06:00:0010      558            600      753            745      138 2013-01-01 06:00:00# … with 336,766 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>select() 可以重命名变量，但尽量避免这样做，因为这样会丢掉所有未明确提及的变量。我们应该使用 select() 函数的变体 rename() 函数来重命名变量，以保留所有未明确提及的变量：</p><pre class="line-numbers language-R"><code class="language-R">dplyr::rename(nycflights13::flights, tail_num = tailnum)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>另一种用法是将 select() 函数和 everything() 辅助函数结合起来使用。当想要将几个变量移到数据框开头时，这种用法非常奏效：</p><pre class="line-numbers language-R"><code class="language-R">dplyr::select(nycflights13::flights, time_hour, air_time, everything())# A tibble: 336,776 × 19   time_hour           air_time  year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier flight tailnum origin dest  distance  hour   <dttm>                 <dbl> <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>     <dbl> <chr>    <int> <chr>   <chr>  <chr>    <dbl> <dbl> 1 2013-01-01 05:00:00      227  2013     1     1      517            515         2      830            819        11 UA        1545 N14228  EWR    IAH       1400     5 2 2013-01-01 05:00:00      227  2013     1     1      533            529         4      850            830        20 UA        1714 N24211  LGA    IAH       1416     5 3 2013-01-01 05:00:00      160  2013     1     1      542            540         2      923            850        33 AA        1141 N619AA  JFK    MIA       1089     5 4 2013-01-01 05:00:00      183  2013     1     1      544            545        -1     1004           1022       -18 B6         725 N804JB  JFK    BQN       1576     5 5 2013-01-01 06:00:00      116  2013     1     1      554            600        -6      812            837       -25 DL         461 N668DN  LGA    ATL        762     6 6 2013-01-01 05:00:00      150  2013     1     1      554            558        -4      740            728        12 UA        1696 N39463  EWR    ORD        719     5 7 2013-01-01 06:00:00      158  2013     1     1      555            600        -5      913            854        19 B6         507 N516JB  EWR    FLL       1065     6 8 2013-01-01 06:00:00       53  2013     1     1      557            600        -3      709            723       -14 EV        5708 N829AS  LGA    IAD        229     6 9 2013-01-01 06:00:00      140  2013     1     1      557            600        -3      838            846        -8 B6          79 N593JB  JFK    MCO        944     610 2013-01-01 06:00:00      138  2013     1     1      558            600        -2      753            745         8 AA         301 N3ALAA  LGA    ORD        733     6# … with 336,766 more rows, and 1 more variable: minute <dbl><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用mutate-添加新变量"><a href="#使用mutate-添加新变量" class="headerlink" title="使用mutate()添加新变量"></a>使用mutate()添加新变量</h3><p>有时还经常需要添加新列，新列是现有列的函数。这就是 mutate() 函数的作用。</p><p>mutate() 总是将新列添加在数据集的最后，因此我们需要先创建一个更狭窄的数据集，以便能够看到新变量。当使用 RStudio 时，查看所有列的最简单的方法就是使用 View() 函数：</p><pre class="line-numbers language-R"><code class="language-R">#首先抽取出一个更小的数据集flights_sml，该数据集由year到day列，以“delay”结束的列、distance列、air_time列组成flights_sml <- dplyr::select(nycflights13::flights, year:day, ends_with("delay"), distance, air_time)dplyr::mutate(flights_sml, gain = arr_delay - dep_delay, speed = distance / air_time * 60)# 使用mutate（）新增gain和speed两列# A tibble: 336,776 × 9    year month   day dep_delay arr_delay distance air_time  gain speed   <int> <int> <int>     <dbl>     <dbl>    <dbl>    <dbl> <dbl> <dbl> 1  2013     1     1         2        11     1400      227     9  370. 2  2013     1     1         4        20     1416      227    16  374. 3  2013     1     1         2        33     1089      160    31  408. 4  2013     1     1        -1       -18     1576      183   -17  517. 5  2013     1     1        -6       -25      762      116   -19  394. 6  2013     1     1        -4        12      719      150    16  288. 7  2013     1     1        -5        19     1065      158    24  404. 8  2013     1     1        -3       -14      229       53   -11  259. 9  2013     1     1        -3        -8      944      140    -5  405.10  2013     1     1        -2         8      733      138    10  319.# … with 336,766 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一旦创建，新列就可以立即使用：</p><pre class="line-numbers language-R"><code class="language-R">dplyr::mutate(flights_sml, gain = arr_delay - dep_delay, hours = air_time / 60, gain_per_hour = gain / hours)# A tibble: 336,776 × 10    year month   day dep_delay arr_delay distance air_time  gain hours gain_per_hour   <int> <int> <int>     <dbl>     <dbl>    <dbl>    <dbl> <dbl> <dbl>         <dbl> 1  2013     1     1         2        11     1400      227     9 3.78           2.38 2  2013     1     1         4        20     1416      227    16 3.78           4.23 3  2013     1     1         2        33     1089      160    31 2.67          11.6  4  2013     1     1        -1       -18     1576      183   -17 3.05          -5.57 5  2013     1     1        -6       -25      762      116   -19 1.93          -9.83 6  2013     1     1        -4        12      719      150    16 2.5            6.4  7  2013     1     1        -5        19     1065      158    24 2.63           9.11 8  2013     1     1        -3       -14      229       53   -11 0.883        -12.5  9  2013     1     1        -3        -8      944      140    -5 2.33          -2.1410  2013     1     1        -2         8      733      138    10 2.3            4.35# … with 336,766 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果只想保留新变量，可以使用 transmute() 函数：</p><pre class="line-numbers language-R"><code class="language-R">dplyr::transmute(nycflights13::flights, gain = arr_delay - dep_delay, hours = air_time / 60, gain_per_hour = gain / hours)# A tibble: 336,776 × 3    gain hours gain_per_hour   <dbl> <dbl>         <dbl> 1     9 3.78           2.38 2    16 3.78           4.23 3    31 2.67          11.6  4   -17 3.05          -5.57 5   -19 1.93          -9.83 6    16 2.5            6.4  7    24 2.63           9.11 8   -11 0.883        -12.5  9    -5 2.33          -2.1410    10 2.3            4.35# … with 336,766 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="常用创建函数"><a href="#常用创建函数" class="headerlink" title="常用创建函数"></a>常用创建函数</h4><p>创建新变量的多种函数可供同 mutate() 一同使用。最重要的一点是，**<font color="red">这种函数必须是向量化的：它必须接受一个向量作为输入，并返回一个向量作为输出，而且输入向量与输出向量具有同样数目的分量。</font>**下面介绍一下比较常用的创建函数。</p><ul><li><p>算术运算符：+、-、*、/、^</p><p>如果一个参数比另一个参数短，那么前者会自动扩展到同样的长度。当某个参数是单个数值时，这种方式是最有效的：air_ time / 60、hours * 60 + minute 等。</p><p>算术运算符的另一用途是与后面将学到的聚集函数结合起来使用。例如，x /  sum(x) 可以计算出各个分量在总数中的比例，y – mean(y) 可以计算出分量与均值之间的差值。</p></li><li><p>模运算符：%/% 和 %%</p><p>%/%（整数除法）和 %%（求余）满足 x == y * (x %/% y) + (x %% y)。模运算非常好用，因为它可以拆分整数。例如，在航班数据集中，你可以根据 dep_time 计算出 hour 和 minute：</p></li></ul><pre class="line-numbers language-R"><code class="language-R">dplyr::transmute(nycflights13::flights, dep_time, hour = dep_time %/% 100, minute = dep_time %% 100)# A tibble: 336,776 × 3   dep_time  hour minute      <int> <dbl>  <dbl> 1      517     5     17 2      533     5     33 3      542     5     42 4      544     5     44 5      554     5     54 6      554     5     54 7      555     5     55 8      557     5     57 9      557     5     5710      558     5     58# … with 336,766 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>对数函数：log()、log2() 和 log10()</p><p>在处理取值范围横跨多个数量级的数据时，对数是特别有用的一种转换方式。它还可以 将乘法转换成加法。</p><p>其他条件相同的情况下，推荐使用 log2() 函数，因为很容易对其进行解释：对数标度的数值增加 1 个单位，意味着初始数值加倍；减少 1 个单位，则意味着初始数值减半。</p></li><li><p>偏移函数</p><p>lead() 和 lag() 函数可以返回一个序列的领先值和滞后值。它们可以计算出序列的移动差值（如 x – lag(x)）或发现序列何时发生了变化（x != lag(x)）。它们与 group_by() 组合使用时特别有用，你很快就会学到 group_by() 这个函数：</p></li></ul><pre class="line-numbers language-R"><code class="language-R">(x <- 1:10)#> [1] 1 2 3 4 5 6 7 8 9 10> dplyr::lag(x) [1] NA  1  2  3  4  5  6  7  8  9> dplyr::lead(x) [1]  2  3  4  5  6  7  8  9 10 NA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>累加和滚动聚合</p><p>R 提供了计算累加和、累加积、累加最小值和累加最大值的函数：cumsum()、cumprod()、 commin() 和 cummax()；dplyr 还提供了 cummean() 函数以计算累加均值。如果想要计算 滚动聚合（即滚动窗口求和），那么可以尝试使用 RcppRoll 包：</p></li></ul><pre class="line-numbers language-R"><code class="language-R">x#> [1] 1 2 3 4 5 6 7 8 9 10cumsum(x)#> [1] 1 3 6 10 15 21 28 36 45 55dplyr::cummean(x)#> [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>逻辑比较：&lt;、&lt;=、&gt;、&gt;= 和 !=</p><p>如果需要进行一系列复杂的逻辑运算，那么最好将中间结果保存在新变量中，这样就可 以检查是否每一步都符合预期。</p></li><li><p>排秩</p><p>排秩函数有很多，但你应该从 min_rank() 函数（**<font color="red">有重复排名，相同值将标为同一排名，会占用多个排名序号</font>**）开始，它可以完成最常用的排秩任务 （如第一、第二、第三、第四）。默认的排秩方式是，最小的值获得最前面的名次，使用 desc(x) 可以让最大的值获得最前面的名次：</p></li></ul><pre class="line-numbers language-R"><code class="language-R">y <- c(1, 2, 2, NA, 3, 4)min_rank(y)#> [1] 1 2 2 NA 4 5min_rank(desc(y))#> [1] 5 3 3 NA 2 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果 min_rank() 无法满足需要，那么可以看一下其变体 row_number()、dense_rank()、 percent_rank()、cume_dist() 和 ntile()。可以查看它们的帮助页面以获得更多信息：</li></ul><pre class="line-numbers language-R"><code class="language-R">row_number(y)#> [1] 1 2 3 NA 4 5dense_rank(y)#> [1] 1 2 2 NA 3 4percent_rank(y)#> [1] 0.00 0.25 0.25 NA 0.75 1.00cume_dist(y)#> [1] 0.2 0.6 0.6 NA 0.8 1.0###<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用summarize-进行分组摘要"><a href="#使用summarize-进行分组摘要" class="headerlink" title="使用summarize()进行分组摘要"></a>使用summarize()进行分组摘要</h3><p>最后一个核心函数是 summarize()，它可以将数据框折叠成一行：</p><pre class="line-numbers language-R"><code class="language-R">dplyr::summarize(nycflights13::flights, delay = mean(dep_delay, na.rm = TRUE))# A tibble: 1 × 1  delay  <dbl>1  12.6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果不与 group_by() 一起使用，那么 summarize() 也就没什么大用。group_by() 可以将分析单位从整个数据集更改为单个分组。接下来，在分组后的数据框上使用 dplyr 函数时， 它们会自动地应用到每个分组。如果对按日期分组的一个数据框应用与上面完全相同的代码，那么我们就可以得到每日平均延误时间：</p><pre class="line-numbers language-R"><code class="language-R">by_day <- group_by(nycflights13::flights, year, month, day)dplyr::summarize(by_day, delay = mean(dep_delay, na.rm = TRUE))# A tibble: 365 × 4# Groups:   year, month [12]    year month   day delay   <int> <int> <int> <dbl> 1  2013     1     1 11.5  2  2013     1     2 13.9  3  2013     1     3 11.0  4  2013     1     4  8.95 5  2013     1     5  5.73 6  2013     1     6  7.15 7  2013     1     7  5.42 8  2013     1     8  2.55 9  2013     1     9  2.2810  2013     1    10  2.84# … with 355 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>group_by() 和 summarize() 的组合构成了使用 dplyr 包时最常用的操作之一：分组摘要。对此之前，先介绍一个功能强大的新概念：管道。</p><h4 id="使用管道组合多种操作"><a href="#使用管道组合多种操作" class="headerlink" title="使用管道组合多种操作"></a>使用管道组合多种操作</h4><p>假设我们想要研究每个目的地的距离和平均延误时间之间的关系。使用已经了解的 dplyr 包功能，你可能会写出以下代码：</p><pre class="line-numbers language-R"><code class="language-R">by_dest <- group_by(nycflights13::flights, dest)delay <- dplyr::summarize(by_dest, count = n(), dist = mean(distance, na.rm = TRUE), delay = mean(arr_delay, na.rm = TRUE))delay <- dplyr::filter(delay, count > 20, dest != "HNL")# 750英里内，平均延误时间会随着距离的增加而增加，接着会随着距离的增加而减少。随着飞 行距离的增加，延误时间有可能会在飞行中弥补回来吗？ggplot(data = delay, mapping = aes(x = dist, y = delay)) + geom_point(aes(size = count), alpha = 1/3) + geom_smooth(se = FALSE)#> `geom_smooth()` using method = 'loess'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="C:\Users\www\Pictures\Rplot15.png"></p><p>完成数据准备需要 3 步。 </p><p>(1) 按照目的地对航班进行分组。</p><p> (2) 进行摘要统计，计算距离、平均延误时间和航班数量。 </p><p>(3) 通过筛选除去噪声点和火奴鲁鲁机场，因为到达该机场的距离几乎是到离它最近机场的距离的 2 倍。</p><p>上述代码中，我们对中间数据框多次命名，这样会影响我们的编码速度。</p><p><strong>解决这个问题的另一种方法是使用管道，%&gt;%：</strong></p><pre class="line-numbers language-R"><code class="language-R">delays <- nycflights13::flights %>% group_by(dest) %>% summarize( count = n(), dist = mean(distance, na.rm = TRUE), delay = mean(arr_delay, na.rm = TRUE)) %>%dplyr::filter(count > 20, dest != "HNL")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这使得代码具有更好的可读性。你可以将其读作一串命令式语句：分组，然后摘要统计，然后进行筛选。在阅读代码时，%&gt;% 最好读作“然后”。举个栗子：</p><p>x %&gt;% f(y) 会转换为 f(x, y)</p><p>x %&gt;% f(y) %&gt;% g(z) 会转换为 g(f(x,  y), z)，以此类推。</p><p>支持管道操作是 tidyverse 中的 R 包的核心原则之一。唯一的例外就是 ggplot2：它是在发现管道方式前开发的。ggplot2 的下一个版本 ggvis 支持管道操作，遗憾的是其还没有达到成熟完备的程度。</p><h4 id="缺失值-1"><a href="#缺失值-1" class="headerlink" title="缺失值"></a>缺失值</h4><p>前面使用了参数 na.rm，你应该非常想要知道其含义。如果没有设置这个参数，会发生什么情况呢？</p><pre class="line-numbers language-R"><code class="language-R">flights %>% group_by(year, month, day) %>% summarize(mean = mean(dep_delay,na.rm=TRUE))# A tibble: 365 × 4# Groups:   year, month [12]    year month   day  mean   <int> <int> <int> <dbl> 1  2013     1     1 11.5  2  2013     1     2 13.9  3  2013     1     3 11.0  4  2013     1     4  8.95 5  2013     1     5  5.73 6  2013     1     6  7.15 7  2013     1     7  5.42 8  2013     1     8  2.55 9  2013     1     9  2.2810  2013     1    10  2.84# … with 355 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-R"><code class="language-R">flights %>% group_by(year, month, day) %>% summarize(mean = mean(dep_delay))# A tibble: 365 × 4# Groups:   year, month [12]    year month   day  mean   <int> <int> <int> <dbl> 1  2013     1     1    NA 2  2013     1     2    NA 3  2013     1     3    NA 4  2013     1     4    NA 5  2013     1     5    NA 6  2013     1     6    NA 7  2013     1     7    NA 8  2013     1     8    NA 9  2013     1     9    NA10  2013     1    10    NA# … with 355 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们会得到很多缺失值！这是因为聚合函数遵循缺失值的一般规则：如果输入中有缺失值，那么输出也会是缺失值。好在所有聚合函数都有一个 na.rm 参数，它可以在计算前除去缺失值。</p><p>在这个示例中，缺失值表示取消的航班，我们也可以通过先去除取消的航班来解决缺失值 问题。保存这个数据集，以便我们可以在接下来的几个示例中继续使用：</p><pre class="line-numbers language-R"><code class="language-R">not_cancelled <- flights %>% filter(!is.na(dep_delay), !is.na(arr_delay))not_cancelled %>% group_by(year, month, day) %>% summarize(mean = mean(dep_delay))# A tibble: 365 × 4# Groups:   year, month [12]    year month   day  mean   <int> <int> <int> <dbl> 1  2013     1     1 11.4  2  2013     1     2 13.7  3  2013     1     3 10.9  4  2013     1     4  8.97 5  2013     1     5  5.73 6  2013     1     6  7.15 7  2013     1     7  5.42 8  2013     1     8  2.56 9  2013     1     9  2.3010  2013     1    10  2.84# … with 355 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h4><p>聚合操作中包括一个计数n()或非缺失值的计数sum(!is_na())。例如，我们查看一下具有最长平均延误时间的飞机（通过机尾编号进行识别）：</p><pre class="line-numbers language-R"><code class="language-R">delays <- not_cancelled %>% group_by(tailnum) %>% summarize( delay = mean(arr_delay) )ggplot(data = delays, mapping = aes(x = delay)) + geom_freqpoly(binwidth = 10)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="G:\R语言Markdown\Rplot16.png"></p><p>画一张航班数量和平均延误时间的散点图，以便获得更深刻的理解：</p><p><img src="G:\R语言Markdown\Rplot17.png"></p><p>当航班数量非常少时，平均延误时间的变动特别大。这张图的形状非常能够说明问题：当绘制均值（或其他摘要统计量）和分组规模的关系时，你总能看到随着样本量的增加，变动在不断减小。</p><p><img src="G:\R语言Markdown\Rplot18.png"></p><p>这种数据模式还有另外一种常见的变体。我们看一下棒球击球手的平均表现与击球次数之间的关系。我们使用 Lahman 包中的数据来计算大联盟的每个棒球队员的打击率（安打数 / 打数）.</p><p>当我绘制出击球手的能力（用打击率 ba 衡量）与击球机会数量（用打数 ab 衡量）之间的关系时，你可以看到两种模式。</p><ul><li>同上，数据点越多，聚合值的变动就越小。</li><li>能力（ba）和击球机会数量（ab）之间存在正相关。这是因为球队会控制击球手的出场， 很显然，球队会优先选择最好的队员。</li></ul><pre class="line-numbers language-R"><code class="language-R"># 转换成tibble，以便输出更美观# 装载Lahman包出错，Lahman<-"https://cran.r-project.org/src/contrib/Lahman_10.0-1.tar.gz"install.packages(Lahman, repos=NULL, type="source")batting <- as_tibble(Lahman::Batting)batters <- batting %>% group_by(playerID) %>% summarize( ba = sum(H, na.rm = TRUE) / sum(AB, na.rm = TRUE), ab = sum(AB, na.rm = TRUE) )batters %>% filter(ab > 100) %>% ggplot(mapping = aes(x = ab, y = ba)) + geom_point() + geom_smooth(se = FALSE)#> `geom_smooth()` using method = 'gam'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="G:\R语言Markdown\Rplot19.png"></p><p>这对球员排名也有重要影响。如果只是使用 desc(ba) 进行排序，明显受益的将是具有最好打击率的球员，而不是能力最高的球员：</p><pre class="line-numbers language-R"><code class="language-R">batters %>% arrange(desc(ba))# A tibble: 20,166 × 3   playerID     ba    ab   <chr>     <dbl> <int> 1 abramge01     1     1 2 alberan01     1     1 3 banisje01     1     1 4 bartocl01     1     1 5 bassdo01      1     1 6 birasst01     1     2 7 bruneju01     1     1 8 burnscb01     1     1 9 cammaer01     1     110 campsh01      1     1# … with 20,156 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="常用的摘要函数"><a href="#常用的摘要函数" class="headerlink" title="常用的摘要函数"></a>常用的摘要函数</h4><p>只使用均值、计数和求和是远远不够的，R 中还提供了很多其他的常用的摘要函数。</p><ul><li><p>位置度量</p><p>已经使用过 mean(x)，但 median(x) 也非常有用。均值是总数除以个数；中位数则是这样一个值：50% 的 x 大于它，同时 50% 的 x 小于它。</p><p>有时候需要将聚合函数和逻辑筛选组合起来使用。</p></li></ul><pre class="line-numbers language-R"><code class="language-R">not_cancelled %>% group_by(year, month, day) %>% summarize( # 平均延误时间： avg_delay1 = mean(arr_delay), # 平均正延误时间： avg_delay2 = mean(arr_delay[arr_delay > 0]) ) # A tibble: 365 × 5# Groups:   year, month [12]    year month   day avg_delay1 avg_delay2   <int> <int> <int>      <dbl>      <dbl> 1  2013     1     1     12.7         32.5 2  2013     1     2     12.7         32.0 3  2013     1     3      5.73        27.7 4  2013     1     4     -1.93        28.3 5  2013     1     5     -1.53        22.6 6  2013     1     6      4.24        24.4 7  2013     1     7     -4.95        27.8 8  2013     1     8     -3.23        20.8 9  2013     1     9     -0.264       25.610  2013     1    10     -5.90        27.3# … with 355 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>分散程度度量：sd(x)、IQR(x) 和 mad(x)</li></ul><p>均方误差（又称标准误差，standard deviation，sd）是分散程度的标准度量方式。四分位距 IQR() 和绝对中位差 mad(x) 基本等价，更适合有离群点的情况：</p><pre class="line-numbers language-R"><code class="language-R"># 为什么到某些目的地的距离比到其他目的地更多变？not_cancelled %>% group_by(dest) %>% summarize(distance_sd = sd(distance)) %>% arrange(desc(distance_sd))# A tibble: 104 × 2   dest  distance_sd   <chr>       <dbl> 1 EGE         10.5  2 SAN         10.4  3 SFO         10.2  4 HNL         10.0  5 SEA          9.98 6 LAS          9.91 7 PDX          9.87 8 PHX          9.86 9 LAX          9.6610 IND          9.46# … with 94 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>秩的度量：min(x)、quantile(x, 0.25) 和 max(x)</li></ul><p>分位数是中位数的扩展。例如，quantile(x, 0.25) 会找出 x 中按从小到大顺序大于前 25% 而小于后 75% 的值：</p><pre class="line-numbers language-R"><code class="language-R"># 每天最早和最晚的航班何时出发？not_cancelled %>% group_by(year, month, day) %>% summarize( first = min(dep_time), last = max(dep_time) )# A tibble: 365 × 5# Groups:   year, month [12]    year month   day first  last   <int> <int> <int> <int> <int> 1  2013     1     1   517  2356 2  2013     1     2    42  2354 3  2013     1     3    32  2349 4  2013     1     4    25  2358 5  2013     1     5    14  2357 6  2013     1     6    16  2355 7  2013     1     7    49  2359 8  2013     1     8   454  2351 9  2013     1     9     2  225210  2013     1    10     3  2320# … with 355 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>定位度量：first(x)、nth(x, 2) 和 last(x)</li></ul><p>这几个函数的作用与 x[1]、x[2] 和 x[length(x)] 相同，只是当定位不存在时（比如尝试从只有两个元素的分组中得到第三个元素），前者允许你设置一个默认值。例如，我们可以找出每天最早和最晚出发的航班：</p><pre class="line-numbers language-R"><code class="language-R">not_cancelled %>% group_by(year, month, day) %>% summarize( first_dep = first(dep_time), last_dep = last(dep_time) )# A tibble: 365 × 5# Groups:   year, month [12]    year month   day first_dep last_dep   <int> <int> <int>     <int>    <int> 1  2013     1     1       517     2356 2  2013     1     2        42     2354 3  2013     1     3        32     2349 4  2013     1     4        25     2358 5  2013     1     5        14     2357 6  2013     1     6        16     2355 7  2013     1     7        49     2359 8  2013     1     8       454     2351 9  2013     1     9         2     225210  2013     1    10         3     2320# … with 355 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些函数对筛选操作进行了排秩方面的补充。筛选会返回所有变量，每个观测在单独的一行中：</p><pre class="line-numbers language-R"><code class="language-R">not_cancelled %>% group_by(year, month, day) %>% mutate(r = min_rank(desc(dep_time))) %>% filter(r %in% range(r))# A tibble: 770 × 20# Groups:   year, month, day [365]    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier flight tailnum origin dest  air_time   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>     <dbl> <chr>    <int> <chr>   <chr>  <chr>    <dbl> 1  2013     1     1      517            515         2      830            819        11 UA        1545 N14228  EWR    IAH        227 2  2013     1     1     2356           2359        -3      425            437       -12 B6         727 N588JB  JFK    BQN        186 3  2013     1     2       42           2359        43      518            442        36 B6         707 N580JB  JFK    SJU        189 4  2013     1     2     2354           2359        -5      413            437       -24 B6         727 N789JB  JFK    BQN        180 5  2013     1     3       32           2359        33      504            442        22 B6         707 N763JB  JFK    SJU        193 6  2013     1     3     2349           2359       -10      434            445       -11 B6         739 N729JB  JFK    PSE        199 7  2013     1     4       25           2359        26      505            442        23 B6         707 N554JB  JFK    SJU        194 8  2013     1     4     2358           2359        -1      429            437        -8 B6         727 N599JB  JFK    BQN        189 9  2013     1     4     2358           2359        -1      436            445        -9 B6         739 N821JB  JFK    PSE        19910  2013     1     5       14           2359        15      503            445        18 B6         739 N592JB  JFK    PSE        201# … with 760 more rows, and 5 more variables: distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>, r <int><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>计数</li></ul><p>你已经见过 n()，它不需要任何参数，并返回当前分组的大小。如果想要计算出非缺失值的数量，可以使用 sum(!is.na(x))。要想计算出唯一值的数量，可以使用 n_ distinct(x)：</p><pre class="line-numbers language-R"><code class="language-R"># 哪个目的地具有最多的航空公司？not_cancelled %>% group_by(dest) %>% summarize(carriers = n_distinct(carrier)) %>% arrange(desc(carriers))# A tibble: 104 × 2   dest  carriers   <chr>    <int> 1 ATL          7 2 BOS          7 3 CLT          7 4 ORD          7 5 TPA          7 6 AUS          6 7 DCA          6 8 DTW          6 9 IAD          610 MSP          6# … with 94 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为计数太常用了，所以 dplyr 提供了一个简单的辅助函数，用于只需要计数的情况：</p><pre class="line-numbers language-R"><code class="language-R">not_cancelled %>% count(dest)# A tibble: 104 × 2   dest      n   <chr> <int> 1 ABQ     254 2 ACK     264 3 ALB     418 4 ANC       8 5 ATL   16837 6 AUS    2411 7 AVL     261 8 BDL     412 9 BGR     35810 BHM     269# … with 94 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你还可以选择提供一个加权变量。例如，你可以使用以下代码算出每架飞机飞行的总里程数（实际上就是求和）：</p><pre class="line-numbers language-R"><code class="language-R">not_cancelled %>% count(tailnum, wt = distance)# A tibble: 4,037 × 2   tailnum      n   <chr>    <dbl> 1 D942DN    3418 2 N0EGMQ  239143 3 N10156  109664 4 N102UW   25722 5 N103US   24619 6 N104UW   24616 7 N10575  139903 8 N105UW   23618 9 N107US   2167710 N108UW   32070# … with 4,027 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>逻辑值的计数和比例：sum(x &gt; 10) 和 mean(y == 0)</li></ul><p>当与数值型函数一同使用时，TRUE 会转换为 1，FALSE 会转换为 0。这使得 sum() 和 mean() 非常适用于逻辑值：sum(x) 可以找出 x 中 TRUE 的数量，mean(x) 则可以找出比例。</p><pre class="line-numbers language-R"><code class="language-R"># 多少架航班是在早上5点前出发的？（这通常表明前一天延误的航班数量）not_cancelled %>% group_by(year, month, day) %>% summarize(n_early = sum(dep_time < 500))# A tibble: 365 × 4# Groups:   year, month [12]    year month   day n_early   <int> <int> <int>   <int> 1  2013     1     1       0 2  2013     1     2       3 3  2013     1     3       4 4  2013     1     4       3 5  2013     1     5       3 6  2013     1     6       2 7  2013     1     7       2 8  2013     1     8       1 9  2013     1     9       310  2013     1    10       3# … with 355 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-R"><code class="language-R"># 延误超过1小时的航班比例是多少？not_cancelled %>% group_by(year, month, day) %>% summarize(hour_perc = mean(arr_delay > 60))# A tibble: 365 × 4# Groups:   year, month [12]    year month   day hour_perc   <int> <int> <int>     <dbl> 1  2013     1     1    0.0722 2  2013     1     2    0.0851 3  2013     1     3    0.0567 4  2013     1     4    0.0396 5  2013     1     5    0.0349 6  2013     1     6    0.0470 7  2013     1     7    0.0333 8  2013     1     8    0.0213 9  2013     1     9    0.020210  2013     1    10    0.0183# … with 355 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="按多个变量分组"><a href="#按多个变量分组" class="headerlink" title="按多个变量分组"></a>按多个变量分组</h4><p>当使用多个变量进行分组时，每次的摘要统计会用掉一个分组变量。这样就可以轻松地对数据集进行循序渐进的分析：</p><pre class="line-numbers language-R"><code class="language-R">daily <- group_by(flights, year, month, day)(per_day <- summarize(daily, flights = n()))# A tibble: 365 × 4# Groups:   year, month [12]    year month   day flights   <int> <int> <int>   <int> 1  2013     1     1     842 2  2013     1     2     943 3  2013     1     3     914 4  2013     1     4     915 5  2013     1     5     720 6  2013     1     6     832 7  2013     1     7     933 8  2013     1     8     899 9  2013     1     9     90210  2013     1    10     932# … with 355 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-R"><code class="language-R">per_month <- summarize(per_day, flights = sum(flights))# A tibble: 12 × 3# Groups:   year [1]    year month flights   <int> <int>   <int> 1  2013     1   27004 2  2013     2   24951 3  2013     3   28834 4  2013     4   28330 5  2013     5   28796 6  2013     6   28243 7  2013     7   29425 8  2013     8   29327 9  2013     9   2757410  2013    10   2888911  2013    11   2726812  2013    12   28135<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-R"><code class="language-R">per_year <- summarize(per_month, flights = sum(flights))# A tibble: 1 × 2   year flights  <int>   <int>1  2013  336776<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在循序渐进地进行摘要分析时，需要小心：使用求和与计数操作是没问题的，但如果想要 使用加权平均和方差的话，就要仔细考虑一下，在基于秩的统计数据（如中位数）上是无 法进行这些操作的。换句话说，对分组求和的结果再求和就是对整体求和，但分组中位数 的中位数可不是整体的中位数</p><h4 id="取消分组"><a href="#取消分组" class="headerlink" title="取消分组"></a>取消分组</h4><p>如果想要取消分组，并回到未分组的数据继续操作，那么可以使用 ungroup() 函数：</p><pre class="line-numbers language-R"><code class="language-R">daily %>% ungroup() %>% # 不再按日期分组 summarize(flights = n()) # 所有航班<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="分组新变量（和筛选器）"><a href="#分组新变量（和筛选器）" class="headerlink" title="分组新变量（和筛选器）"></a>分组新变量（和筛选器）</h3><p>虽然与 summarize() 函数结合起来使用是最有效的，但分组也可以与 mutate() 和 filter() 函数结合，以完成非常便捷的操作。</p><ul><li>找出每个分组中最差的成员：</li></ul><pre class="line-numbers language-R"><code class="language-R">flights_sml <- flights %>% group_by(year, month, day) %>% filter(rank(desc(arr_delay)) < 10)flights_sml# A tibble: 3,306 × 19# Groups:   year, month, day [365]    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int> 1  2013     1     1      848           1835       853     1001           1950 2  2013     1     1     1815           1325       290     2120           1542 3  2013     1     1     1842           1422       260     1958           1535 4  2013     1     1     1942           1705       157     2124           1830 5  2013     1     1     2006           1630       216     2230           1848 6  2013     1     1     2115           1700       255     2330           1920 7  2013     1     1     2205           1720       285       46           2040 8  2013     1     1     2312           2000       192       21           2110 9  2013     1     1     2343           1724       379      314           193810  2013     1     2     1244            900       224     1431           1104# … with 3,296 more rows, and 11 more variables: arr_delay <dbl>, carrier <chr>,#   flight <int>, tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>,#   distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>找出大于某个阈值的所有分组：</li></ul><pre class="line-numbers language-R"><code class="language-R">popular_dests <- flights %>% group_by(dest) %>% filter(n() > 365)popular_dests# A tibble: 332,577 × 19# Groups:   dest [77]    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int> 1  2013     1     1      517            515         2      830            819 2  2013     1     1      533            529         4      850            830 3  2013     1     1      542            540         2      923            850 4  2013     1     1      544            545        -1     1004           1022 5  2013     1     1      554            600        -6      812            837 6  2013     1     1      554            558        -4      740            728 7  2013     1     1      555            600        -5      913            854 8  2013     1     1      557            600        -3      709            723 9  2013     1     1      557            600        -3      838            84610  2013     1     1      558            600        -2      753            745# … with 332,567 more rows, and 11 more variables: arr_delay <dbl>, carrier <chr>,#   flight <int>, tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>,#   distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对数据进行标准化以计算分组指标：</li></ul><pre class="line-numbers language-R"><code class="language-R">popular_dests %>% filter(arr_delay > 0) %>% mutate(prop_delay = arr_delay / sum(arr_delay)) %>% select(year:day, dest, arr_delay, prop_delay)# A tibble: 131,106 × 6# Groups:   dest [77]    year month   day dest  arr_delay prop_delay   <int> <int> <int> <chr>     <dbl>      <dbl> 1  2013     1     1 IAH          11  0.000111  2  2013     1     1 IAH          20  0.000201  3  2013     1     1 MIA          33  0.000235  4  2013     1     1 ORD          12  0.0000424 5  2013     1     1 FLL          19  0.0000938 6  2013     1     1 ORD           8  0.0000283 7  2013     1     1 LAX           7  0.0000344 8  2013     1     1 DFW          31  0.000282  9  2013     1     1 ATL          12  0.000040010  2013     1     1 DTW          16  0.000116 # … with 131,096 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分组筛选器的作用相当于分组新变量加上未分组筛选器。我一般不使用分组筛选器，除非是为了完成快速、粗略的数据处理，否则很难检查数据处理的结果是否正确。</p><p>在分组新变量和筛选器中最常使用的函数称为窗口函数（与用于统计的摘要函数相 对）。你可以在相应的使用指南中学习到更多关于窗口函数的知识：vignette(“window-functions”)。</p>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>R4DS读书笔记（第二章、工作流：基础）</title>
      <link href="/2022/05/19/r4ds-du-shu-bi-ji-di-er-zhang-gong-zuo-liu-ji-chu/"/>
      <url>/2022/05/19/r4ds-du-shu-bi-ji-di-er-zhang-gong-zuo-liu-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="代码基础"><a href="#代码基础" class="headerlink" title="代码基础"></a>代码基础</h2><p>创建对象使用下列的形式</p><pre class="line-numbers language-R"><code class="language-R">object_name <- value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Rstudio中常使用“alt+减号”生成赋值符号“&lt;-”</p><h2 id="对象名称"><a href="#对象名称" class="headerlink" title="对象名称"></a>对象名称</h2><p>使用对象名不能有错误，区分大小写，需要严格准确，在rstudio里输入this,使用按 Ctrl+ ↑可查询所有使用了以“this”为前缀的命令。</p><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>内置函数的调用方式如下：</p><pre class="line-numbers language-R"><code class="language-R">function_name(arg1 = val1, arg2 = val2, ...)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用tab键帮助预测下一步命令、使用↑和↓箭头键来选择命令，自动补齐命令。注意弹出的浮动提示信息，它可以告诉你这个函数的参数和作用。如果想要获得更多帮助，按 F1 键就可以在右下角窗格的帮助标签页中看到详细的帮助信息。</p><p>引号和括号必须一直成对出现。RStudio 会尽力帮助我们，但如果出现不匹配，R 会显示一个 + 号提示R 在等待继续输入。</p><p>如果进行了一次赋值，R 不会显示出赋值结果。你最好立刻打印出来检查一下：</p><pre class="line-numbers language-R"><code class="language-R">y <- seq(1, 10, length.out = 5)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -R语言 -数据可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R4DS读书笔记（第一章、使用ggplot2数据可视化）</title>
      <link href="/2022/05/18/r4ds-du-shu-bi-ji-di-yi-zhang-shi-yong-ggplot2-shu-ju-ke-shi-hua/"/>
      <url>/2022/05/18/r4ds-du-shu-bi-ji-di-yi-zhang-shi-yong-ggplot2-shu-ju-ke-shi-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="R4DS读书笔记（第一章、使用ggplot2数据可视化）"><a href="#R4DS读书笔记（第一章、使用ggplot2数据可视化）" class="headerlink" title="R4DS读书笔记（第一章、使用ggplot2数据可视化）"></a>R4DS读书笔记（第一章、使用ggplot2数据可视化）</h1><p>最近在啃Hadley Wickham大佬的经典著作，R4DS（R for Data Science，中译本：R数据科学），经典的数据科学的项目分析应当遵循以下流程，而作者将最精彩的部分也就是数据可视化内容前置，让我们率先获得学习R语言之后可以用来干什么，能做出什么样的图表。<img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E6%B5%81%E7%A8%8B%E5%9B%BE1.png"></p><pre class="line-numbers language-R"><code class="language-R">install.packages("tidyverse")#安装tidyverse这个packagelibrary(tidyverse)#加载tidyverse这个package#如果想调用某个包里的具体函数，可使用以下语法结构：package::function()#例如ggplot2::ggplot()就是调用ggplot2包中的ggplot函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><h3 id="引入mpg数据框"><a href="#引入mpg数据框" class="headerlink" title="引入mpg数据框"></a>引入mpg数据框</h3><p>使用ggplot2包中自带的mpg数据框，在console里输入mpg，可展示mpg数据的相关信息（234行观测*11列变量的数据框）</p><h3 id="创建ggplot图形"><a href="#创建ggplot图形" class="headerlink" title="创建ggplot图形"></a>创建ggplot图形</h3><pre class="line-numbers language-R"><code class="language-R">ggplot(data=mpg)+    geom_point(mapping = aes(x=displ,y=hwy))#ggplot(data=mpg) ggplot() 函数创建了一个坐标系，可以在上面添加图层，ggplot(data = mpg)创建一张空白图#函数 geom_point() 向图中添加一个点层，这样就可以创建一张散点图#ggplot2中的每个几何对象函数都有一个 mapping参数。mapping参数总是与aes()函数成对出现，aes()函数的x参数和y参数分别指定了映射到x轴的变量与映射到y轴的变量。ggplot2在data参数中寻找映射变量，本例中就是mpg。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE1.png"></p><h3 id="使用ggplot绘图的语法模板"><a href="#使用ggplot绘图的语法模板" class="headerlink" title="使用ggplot绘图的语法模板"></a>使用ggplot绘图的语法模板</h3><pre class="line-numbers language-R"><code class="language-R">ggplot(data = <DATA>) + <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))#由上面我们可以抽象出ggplot绘图的语法模板<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="图形的属性映射"><a href="#图形的属性映射" class="headerlink" title="图形的属性映射"></a>图形的属性映射</h2><p>可以向二维散点图中添加<strong>第三个变量</strong>，比如 class，方式是将它<strong>映射为图形属性</strong>。<strong>图形属性是图中对象的可视化属性，其中包括数据点的大小、形状和颜色。</strong>通过改变图形属性的值，可以用不同的方式来显示数据点。</p><pre class="line-numbers language-R"><code class="language-R">#将点的颜色映射为变量 class，从而揭示每辆汽车的类型ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = class))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%BD%B1%E5%83%8F2.png"></p><p>除了将class映射为颜色外，还可将其映射为点的大小，但此时会收到一条warning ‘Using size for a discrete variable is not advised’，将无序变量（class）映射为有序图形属性（size）不是一个很好的建议。<img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE2.png"></p><p>此外我们还可以将class映射为控制数据点<strong>透明度</strong>的alpha图形属性，也可映射为<strong>点的形状</strong></p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, alpha = class))#这里同样给出了warning：Using alpha for a discrete variable is not advised<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE3.png"></p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, shape = class))#这里同样给出了warning：1: The shape palette can deal with a maximum of 6 discrete values because more than 6 becomes difficult to discriminate; you have 7. Consider specifying shapes manually if you must have them. 2: Removed 62 rows containing missing values (geom_point)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE4.png"></p><p>默认情况下，ggplot2 只能同时使用 6 种形状，多出的变量值将不会出现在图中。</p><p>此外，我们还可以<strong>手动为几何对象设置图形属性</strong>，例如让所有的点都是<font color="blue">蓝色</font>:</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data=mpg)+    geom_point(mapping= aes(x=displ,y=hwy),color="blue")#手动设置图形属性，为几何对象函数的一个参数,需要在函数 aes() 的外部进行设置。#写代码的时候要注意，+号应放在每一行的末尾而不是开头<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE5.png"></p><h2 id="分面"><a href="#分面" class="headerlink" title="分面"></a>分面</h2><p>添加额外变量的一种方法是使用图形属性。另一种方法是<strong>将图分割成多个分面</strong>，即可以显示数据子集的子图。这种方法特别适合添加分类变量。使用函数 facet_wrap()通过单个变量对图进行分面，第一个参数是一个公式，创建公式的方式是在 ~ 符号后面加一个变量名，<strong>传递给 facet_wrap() 的变量应该是离散型的</strong></p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_wrap(~ class, nrow = 2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE6.png"></p><p>通过两个变量对图进行分面，需要在绘图命令中加入函数 facet_grid()。这个函数的 第一个参数也是一个公式，但该公式包含由 ~ 隔开的两个变量名。</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_grid(drv ~ cyl)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE7.png"></p><p>如果不想在行或列的维度进行分面，你可以使用 . 来代替变量名，例如 + facet_grid(. ~  cyl)</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_grid(.~ cyl)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE8.png"></p><h2 id="几何对象"><a href="#几何对象" class="headerlink" title="几何对象"></a>几何对象</h2><p><strong>几何对象是图中用来表示数据的几何图形对象。</strong>可以使用不同的几何对象来表示同样的数据。如下图，左侧的图使用了点几何对象，右侧的图使用了平滑曲线几何对象，以一条平滑曲线来拟合数据。</p><pre class="line-numbers language-R"><code class="language-R"># 左图ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy))# 右图ggplot(data = mpg) + geom_smooth(mapping = aes(x = displ, y = hwy))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE9.png"></p><p>我们无法设置线的形状，但是可以通过linetype设置线型</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg) + geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv))#一条线表示 drv 值为 4 的所有汽车，一条线表示 drv 值为 f 的所有汽车，另一条线表示 drv 值为 r 的所有汽车。其中 4 表示四轮驱动，f 表示前轮驱动，r 表示后轮驱动<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE10.png"></p><p>只要将一个图形属性映射为一个离散变量（如上个示例中的 linetype），ggplot2 就会自动对数据进行分组来绘制多个几何对象。</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg) + geom_smooth( mapping = aes(x = displ, y = hwy, color = drv), show.legend = FALSE )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE11.png"></p><p>此外，可以将这些几何对象的 group 图形属性设置为一个分类变量，这样 ggplot2 就会为这个分类变量的每个唯一值绘制一个独立的几何对象。</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg) + geom_smooth(mapping = aes(x = displ, y = hwy, group = drv))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE12.png"></p><p><strong>如果在同一张图中显示多个几何对象，可以向 ggplot() 函数中添加多个几何对象函数：</strong></p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + geom_smooth(mapping = aes(x = displ, y = hwy))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE13.png"></p><p>但是这么写代码的话，会显得很罗嗦，每次要往空白图上添加一次几何对象，就得重复一次aes(x=?,y=?)。<strong>避免重复的方法是将一组映射直接传递给 ggplot() 函数，ggplot2 会将这些映射作为全局映射应用到图中的每个几何对象中,下面的代码与上面的代码效果一致</strong></p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point() + geom_smooth()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果将映射放在几何对象函数中，那么 ggplot2 会将其看作这个图层的局部映射，它将使用这些映射扩展或覆盖全局映射，但仅对该图层有效。这样一来，我们就可以在不同的图层中显示不同的图形属性：</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point(mapping = aes(color = class)) + geom_smooth()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE14.png"></p><p>同理，为不同的图层可以分别指定不同的数据</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point(mapping = aes(color = class)) + geom_smooth(color="green")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE15.png"></p><h2 id="统计变换"><a href="#统计变换" class="headerlink" title="统计变换"></a>统计变换</h2><p>使用基本的geom_bar() 函数可绘制基本的条形图，diamonds 数据集是 ggplot2 的内置数据集，大约包含 54 000 颗钻石的信息，每颗钻石具有 price、carat、color、 clarity 和 cut 变量。</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut))#按照 cut 变量分组的各种钻石的总数量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE16.png"></p><p>前面的散点图是用来描绘数据集已有原始数据信息的。但是y轴上的count不是diamonds的变量，这里描述产生的新数据使用的是条形图。</p><ul><li><p>条形图、直方图和频率多边形图可以对数据进行分箱（<strong>数据分箱操作</strong>），然后绘制出分箱数量和落在每个分箱的数据点的数量。</p></li><li><p>平滑曲线会为数据拟合一个模型，然后绘制出<strong>模型预测值</strong>。</p></li><li><p>箱线图可以计算出数据分布的多种摘要统计量（<strong>计算多种统计量</strong>），并显示一个特殊形式的箱体。</p></li></ul><p>绘图时用来<strong>计算新数据的算法称为 stat（statistical transformation，统计变换）</strong>。</p><p>通常来说，几何对象函数和统计变换函数可以互换使用。例如，你可以使用 stat_count() 替换 geom_bar() 来重新生成前面那张图：</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = diamonds) + stat_count(mapping = aes(x = cut))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>显式使用某种统计变换的 3 个原因如下:</p><ul><li><p>覆盖默认的统计变换。在以下代码中，将 geom_bar() 函数的统计变换从计数（默认值）修改为标识。这样就可以将条形的高度映射为 y 轴变量的初始值。</p><pre class="line-numbers language-R"><code class="language-R">demo <- tribble( ~a, ~b, "bar_1", 20, "bar_2", 30, "bar_3", 40)ggplot(data = demo) + geom_bar( mapping = aes(x = a, y = b), stat = "identity" )#不同于前面计数才能生成数据，条形图高度数据已经存在于数据集中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot.png"></p></li><li><p>覆盖从统计变换生成的变量到图形属性的默认映射。例如，你或许想显示一 张表示比例（而不是计数）的条形图：</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = diamonds) + geom_bar( mapping = aes(x = cut, y = ..prop.., group = 1) )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE17.png"></p><ul><li><p>想要在代码中强调统计变换。例如，你可以使用 stat_summary() 函数将人们的注意力吸引到你计算出的那些摘要统计量上。stat_summary() 函数为 x 的每个唯一值计算 y 值的摘要统计：</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = diamonds) + stat_summary( mapping = aes(x = cut, y = depth), fun.ymin = min, fun.ymax = max, fun.y = median)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="位置调整"><a href="#位置调整" class="headerlink" title="位置调整"></a>位置调整</h2><p>在这里，条形图可使用使用color或者fill来上色，下面展示两者的不同</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, color = cut))ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = cut))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot01.png" style="zoom:80%;" align="center"><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot02.png" style="zoom:80%;" align="center"><p><strong>注意，如果将 fill 图形属性映射到另一个变量（如 clarity），那么条形会自动分块堆叠起来。每个彩色矩形表示 cut 和 clarity 的一种组合。</strong></p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = clarity))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot03.png"></p><p>这种堆叠是由 position 参数设定的位置调整功能自动完成的。如果不想生成堆叠式条形图，你还可以使用以下 3 种选项之一：”identity”、”fill” 和 “dodge”。</p><ul><li><p>position = “identity” 将每个对象直接显示在图中。这种方式不太适合条形图，因为 条形会彼此重叠。为了让重叠部分能够显示出来，我们可以设置 alpha 参数为一个较小 的数，从而使得条形略微透明；或者设定 fill = NA，让条形完全透明：</p><pre class="line-numbers language-R"><code class="language-R">ggplot( data = diamonds, mapping = aes(x = cut, fill = clarity)) + geom_bar(alpha = 1/5, position = "identity")ggplot( data = diamonds, mapping = aes(x = cut, color = clarity)) + geom_bar(fill = NA, position = "identity")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot04.png"></p></li><li><p>position = “fill” 的效果与堆叠相似，但每组堆叠条形具有同样的高度，因此这种条形图可以非常轻松地比较各组间的比例：</p><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot05.png"></p></li><li><p>position = “dodge” 将每组中的条形依次并列放置，这样可以非常轻松地比较每个条形表示的具体数值：</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = diamonds) + geom_bar( mapping = aes(x = cut, fill = clarity), position = "dodge" )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot06.png"></p></li></ul><p>此外还有一种关于散点图的位置调整，在一个网格上，很多点彼此重叠。这个问题称为<strong>过绘制</strong>。通过将位置调整方式设为“抖动”，可以避免这种网格化排列。position = “jitter” 为每个数据点添加一个很小的随机扰动，这样就可以将重叠的点分散开来</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg) + geom_point( mapping = aes(x = displ, y = hwy), position = "jitter" )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot07.png" style="zoom:80%;" align="center"><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot08.png" style="zoom:80%;" align="center"><h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><p>默认坐标系是笛卡儿直角坐标系，可以通过其 独立作用的 x 坐标和 y 坐标找到每个数据点。</p><ul><li><p>coord_flip() 函数可以交换 x 轴和 y 轴。当想要绘制水平箱线图时，这非常有用。它也非常适合使用长标签，但要想在 x 轴上不重叠地安排好它们是非常困难的：</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + geom_boxplot()ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + geom_boxplot() + coord_flip()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot09.png" style="zoom:80%;" align="center"><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot10.png" style="zoom:80%;" align="center"></li><li><p>coord_quickmap() 函数可以为地图设置合适的纵横比。当使用 ggplot2 绘制空间数据时， 这个函数特别重要。</p><pre class="line-numbers language-R"><code class="language-R">nz <- map_data("nz")ggplot(nz, aes(long, lat, group = group)) + geom_polygon(fill = "white", color = "black")ggplot(nz, aes(long, lat, group = group)) + geom_polygon(fill = "white", color = "black") + coord_quickmap()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot11.png" style="zoom:80%;" align="center"><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot12.png" style="zoom:80%;" align="center"></li><li><p>coord_polar() 函数使用极坐标系。极坐标系可以揭示出条形图和鸡冠花图间的一种有趣联系：</p><pre class="line-numbers language-R"><code class="language-R">bar <- ggplot(data = diamonds) + geom_bar( mapping = aes(x = cut, fill = cut), show.legend = FALSE, width = 1 ) + theme(aspect.ratio = 1) + labs(x = NULL, y = NULL)bar + coord_flip()bar + coord_polar()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot13.png" style="zoom:80%;" align="center"><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot14.png" style="zoom:80%;" align="center"></li></ul><h2 id="图形分层语法"><a href="#图形分层语法" class="headerlink" title="图形分层语法"></a>图形分层语法</h2><p>通过前面的绘制散点图、条形图和箱线图，我们掌握了使用 ggplot2 绘制任何类型图形的基础知识。</p><p>这里我们给出在前面的代码模板中添加位置调整、统计变换、坐标系和分面，给出一般情况下的使用ggplot2绘图的语法模板</p><pre class="line-numbers language-R"><code class="language-R"># ggplot(data = <<data>>) +# <<GEOM_FUNCTION>>(# mapping = aes(<<MAPPINGS>>),# stat = <<STAT>>,# position = <<POSITION>># ) +# <<COORDINATE_FUNCTION>> +# <<FACET_FUNCTION>><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新模板有 7 个参数，即模板中尖括号内的部分。但实际上，绘图时几乎不需要提供所有的 7 个参数，因为除了数据、映射和几何对象函数，ggplot2 为所有其他参数提供了非常有用的默认设置。</p><p><strong>将任何图形精确地描述为数据集、几何对象、映射集合、统计变换、位置调整、坐标系和分面模式的一个组合，图形语法正是基于这样的深刻理解构建出来的。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
            <tag> 数据可视化 </tag>
            
            <tag> ggplot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建博客杂谈</title>
      <link href="/2022/05/11/da-jian-bo-ke-za-tan/"/>
      <url>/2022/05/11/da-jian-bo-ke-za-tan/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建博客杂谈"><a href="#搭建博客杂谈" class="headerlink" title="搭建博客杂谈"></a>搭建博客杂谈</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>坦白说，这次注册的域名的命名确实有玩梗的成分在：<a href="https://flying2the.top/">https://flying2the.top</a> （当然也是方便记忆了）</p><h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p>本地安装<a href="https://nodejs.org/en/">Node.js (nodejs.org)</a></p><p>进入本地终端，使用下列命令检查是否安装成功</p><pre class="line-numbers language-shell"><code class="language-shell">node -vnpm -vnpm config set registry https://registry.npm.taobao.org #添加国内镜像源<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>本地安装<a href="https://git-scm.com/downloads">Git - Downloads (git-scm.com)</a></p><p>进入终端，检验git是否正确安装：</p><pre class="line-numbers language-shell"><code class="language-shell">git --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="注册GitHub账号，创建一个新repo"><a href="#注册GitHub账号，创建一个新repo" class="headerlink" title="注册GitHub账号，创建一个新repo"></a>注册GitHub账号，创建一个新repo</h2><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/repo.png"></p><p>选择GitHub pages主题</p><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/theme.png"></p><h2 id="本地安装hexo"><a href="#本地安装hexo" class="headerlink" title="本地安装hexo"></a>本地安装hexo</h2><p>新建一个blog文件夹，该目录下右键点击<code>Git Bash Here</code>，打开git的shell，输入<code>npm i hexo-cli -g</code>安装Hexo，</p><p>安装完后输入<code>hexo -v</code>验证是否安装成功，输入<code>hexo init</code>初始化文件夹，接着输入<code>npm install</code>安装必备的组件。</p><p>最常用的几个命令：</p><pre class="line-numbers language-shell"><code class="language-shell">hexo g #本地buildhexo s #本地启动服务，可通过本地的4000端口预览hexo d #deploy到GitHub服务器上<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="本地生成密钥"><a href="#本地生成密钥" class="headerlink" title="本地生成密钥"></a>本地生成密钥</h2><p>注册自有的Github账号，右键打开git bash，然后输入下面命令：</p><pre class="line-numbers language-shell"><code class="language-shell">git config --global user.name "GuoYu2022"git config --global user.email "yg9655@icloud.com"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后生成密钥SSH key：</p><pre class="line-numbers language-shell"><code class="language-shell">ssh-keygen -t rsa -C "yg9655@icloud.com"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>GitHub的设置里面新建一个SSH，在bash中输入</p><pre class="line-numbers language-shell"><code class="language-shell">cat ~/.ssh/id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将读取出的密钥信息复制到GitHub的SSH里面</p><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-05-11%20143240.png"></p><p>输入<code>ssh -T git@github.com</code>，如果出现用户名，说明已经成功</p><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/1.png"></p><h2 id="执行Hexo-d报错Spawn-failed，-以及OpenSSL-SSL-read-Connection-was-reset-errno-10054"><a href="#执行Hexo-d报错Spawn-failed，-以及OpenSSL-SSL-read-Connection-was-reset-errno-10054" class="headerlink" title="执行Hexo d报错Spawn failed， 以及OpenSSL SSL_read: Connection was reset, errno 10054"></a><font color="red"><strong>执行Hexo d报错Spawn failed， 以及OpenSSL SSL_read: Connection was reset, errno 10054</strong></font></h2><p>在部署时报了这样的错误，解决方法如下</p><pre class="line-numbers language-shell"><code class="language-shell">ssh git@github.com #首先检测SSH密钥是否有效hexo config deploy.repository git@github.com:GuoYu2022/GuoYu2022.github.io.git # 参考这一句解决hexo config deploy.repository git@github.com:[yourgitname]/[yourgitname].github.io.githexo d #最后就可以deploy了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="对于每次部署新博文到GitHub上时，重定向域名失效问题的解决方法"><a href="#对于每次部署新博文到GitHub上时，重定向域名失效问题的解决方法" class="headerlink" title="对于每次部署新博文到GitHub上时，重定向域名失效问题的解决方法"></a><font color="red"><strong>对于每次部署新博文到GitHub上时，重定向域名失效问题的解决方法</strong></font></h2><p>首先需要确定GitHub仓库根目录下已有CNAME文件，在本地博客根目录文件夹下<strong>source</strong> 文件夹里新建一个CNAME文件（<font color="red"><strong>注意该文件没有后缀名</strong></font>），内容为你的域名<code>flying2the.top</code>（<font color="red"><strong>这里不需要写www或者https</strong></font>），然后hexo g -d</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>R语言数据处理基础</title>
      <link href="/2022/05/11/r-yu-yan-shu-ju-chu-li-ji-chu/"/>
      <url>/2022/05/11/r-yu-yan-shu-ju-chu-li-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>在 R 中有许多用于数据框基本操作的内置函数，比如 transform()、rbind()、cbind()等函数，都是基于base 包的。base 包是安装 R 时会自带的包，无须加载包就可以直接使用。除此之外，还有如下 几种常用的数据处理的包。</p><p>（1）dplyr 包：dplyr 包是 Hadley Wickham（ggplot2 包的作者）的杰作，他将原本 plyr 包中的 ddply()等函数进一步分离强化， 专注接受 dataframe 对象，大幅提高了速度，并且提供了更稳健地与其他数据库对象间的接口。该包常用的函数包括：<strong>变量筛选函数 select()、记录筛选函数 filter()、排序函数 arrange()、变形（计算） 函数 mutate()、汇总函数 summarize()、分组函数 group_by()、随机抽样函数 sample_n()和 sample_frac()， 以及多步操作连接符 %&gt;%等。</strong></p><p>（2）tidyr 包：在具体应用中，tidyr 包经常与 dplyr 包共同使用，目前渐有取代 reshape2 包之势， 是值得关注的一个 R 包。在 tidyr 包中，有 4 个常用的函数，分别是：<strong>gather()函数用于将宽数据转换为长数据；spread()函数用于将长数据转换为宽数据；unite()函数用于将多列数据合并为一列数据； separate()函数用于将一列数分离为多列数。</strong></p><p>（3）reshape2 包：reshape2 包是由 Hadley Wickham 开发的<strong>用于数据重构的包</strong>，主要功能函数为 melt()、cast()，其实现了长数据和宽数据之间的转换，包中还包含 add_margin()等其他函数和 french_fries（三种不同的油对薯条口感的影响）等数据集。</p><p>（4）tidyverse 包：tidyverse 是由 Hadley Wickham 于 2017 年创建的 R 包的集合，它“分享整洁数据的基础设计理念、语法和数据结构”。核心软件包是 ggplot2、dplyr、tidyr、readr、purrr、tibble、 stringr 和 forcats，它们提供了建模、转换和可视化数据的功能。更多内容可以见他出版的新书 R for  Data Science。其中，readr 包用于读取数据，tidyr 包用于整理数据，dplyr 包用于数据转换，ggplot2 包用于数据可视化，purrr 包用于函数式编程。大家如对此有兴趣，可以更加深入地学习。</p><h2 id="这里简单介绍一下一维表和二维表的区别"><a href="#这里简单介绍一下一维表和二维表的区别" class="headerlink" title="这里简单介绍一下一维表和二维表的区别"></a>这里简单介绍一下一维表和二维表的区别</h2><p>一维数据列表就是由字段和记录组成的表格。一般来说字段在首行， 下面每一行是一条记录。一维数据列表通常可以作为数据分析的数据源， 每一行代表完整的一条数据记录，所以可以很方便地进行数据的录入、 更新、查询、匹配等。<strong>仅需通过单行就能确定数值的，被称为一维表。</strong></p><p><img src="https://pic1.zhimg.com/80/v2-066d0eb84c4abf113c6f32f6e960e55c_720w.jpg"></p><p>为了方便浏览打印美观，很多人会把重复姓名合并单元格，如下图（合并单元格只是格式美观，对数据清洗反而是一大障碍，会耗费额外时间精力）</p><p><img src="https://pic2.zhimg.com/80/v2-bb0b2f10101044f57348c7d6a4038af1_720w.png"></p><p>二维数据列表就是行和列都有字段，它们相交的位置是数值的表格。 这类表格一般是由分类汇总得来的，既有分类，又有汇总，所以是通过 一维数据列表加工处理过的，通常用于呈现展示。<strong>确定一个数值，必须通过行列两个条件去定位，这是二维表最显著的特征</strong>，如下图：</p><p><img src="https://pic1.zhimg.com/80/v2-4939d593f8d439fa57aee14ab2fd68e0_720w.jpg"></p><p>最早接触一维表的，是那些数据库从业者，因为一维表大都是系统自动生成的。但凡从数据库系统里导出来的表，不管是XLS还是CSV，都是一维表样式。<strong>换句话说，一维表是符合数据库设计规范的，需要行和列来定位数值的，就是二维表；仅靠单行就能锁定全部信息的，就是一维表</strong>，一维表、二维表可以相互转换。一维转二维用透视表，反之用逆透视。</p><h2 id="2-1表格的转换"><a href="#2-1表格的转换" class="headerlink" title="2.1表格的转换"></a>2.1表格的转换</h2><h3 id="2-1-1表格的变换"><a href="#2-1-1表格的变换" class="headerlink" title="2.1.1表格的变换"></a>2.1.1表格的变换</h3><p>在使用 R ggplot2 绘图时，通常使用一维数据列表的数据框。但是如果导入的数据表格是二维数据列表，我们则需要使用 reshape2 包的 melt()函数或者 tidyr 包的 gather()函数，可以<strong>将二维数据列表的数据框转换成一维数据列表，首先构造数据框：</strong></p><pre class="line-numbers language-R"><code class="language-R">df<- data.frame(x=c('A','B','C'),'2010'=c(1,3,4),'2011'=c(3,5,2),check.names=FALSE)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（1）将宽数据转换为长数据，将多行聚集成列，从而将二维数据列表变成一维数据列表：</p><pre class="line-numbers language-R"><code class="language-R">df_melt<- reshape2::melt(df, id.vars="x",variable.name="year",value.name = "value")df_gather<- tidyr:: gather(df,year,value,-x#以上两句实现相同的效果<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中，id.vars (“x”)表示由标识变量构成的向量，用于标识观测的变量；variable.name (“year”)表示用于保存原始变量名的变量的名称；value.name(“value”)表示用于保存原始值的名称。</p><p>（2）将长数据转换为宽数据，将一列根据变量展开为多行，从而将一维数据列表变成二维数据列表：</p><pre class="line-numbers language-R"><code class="language-R">df_dcast<- reshape2:: dcast (df_melt,x~year,value.var="value")df_spread <- tidyr::spread(df_gather,year, value)#以上两句实现相同的效果<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中，dcast 借助于公式来描述数据的形状 id.vars~variable.name，左边参数表示 id.vars (“x”)， 而右边的参数表示 variable.name (“year”)。</p><p><font color="purple">&nbsp;<strong>此处插入图片</strong></font></p><h3 id="2-1-2变量的变换"><a href="#2-1-2变量的变换" class="headerlink" title="2.1.2变量的变换"></a>2.1.2变量的变换</h3><p>有时候，需要对数据框中某列的每个元素都进行运算处理，从而产生并添加新的列。可以使用 R 内置函数 transform()为原数据框添加新的列，可以改变原变量列的值， 也可以赋值 NULL 删除列变量：</p><pre class="line-numbers language-R"><code class="language-R">dat1<-transform(df_melt, value2=value*2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以结合向量化的条件语句 ifelse()进行复杂运算。另外，dplyr 包的 mutate()函数也能实现与 transform()函数相同的功能。但是 mutate()函数很好地解决了 transform()函数不能解决的 问题，即 mutate()函数允许新列对刚刚建立起来的列进行计算。</p><pre class="line-numbers language-R"><code class="language-R">dat2<- transform(df_melt, value2=ifelse(year=="2011", value*2, value))dat2<- dplyr:: mutate(df_melt, value2=ifelse(year=="2011", value*2, value)#将2011年的数据翻倍<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><font color="purple"> <strong>此处插入图片</strong></font></p><h3 id="2-1-3表格的排序"><a href="#2-1-3表格的排序" class="headerlink" title="2.1.3表格的排序"></a>2.1.3表格的排序</h3><p>此外可以使用 sort()函数对向量进行排序处理。对于数据框，我们可使用 dplyr 包的 arrange()函数，根据数据框的某列数值对整个表排序。其中 desc(value)表示根据 df 的 value 列做降序处理，如 dat_arrange2 数据框所示。</p><pre class="line-numbers language-R"><code class="language-R">dat_arrange1<- dplyr:: arrange (df_melt, value)dat_arrange2<- dplyr:: arrange (df_melt, desc(value))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><font color="purple"> <strong>此处插入图片</strong></font></p><h2 id="2-2表格的整理"><a href="#2-2表格的整理" class="headerlink" title="2.2表格的整理"></a>2.2表格的整理</h2><h3 id="2-2-1表格的拼接"><a href="#2-2-1表格的拼接" class="headerlink" title="2.2.1表格的拼接"></a>2.2.1表格的拼接</h3><p>需要在已有数据框的基础上添加新的行/列，或者横向/纵向添加另外一个表格。此时需要使用R内置函数 cbind()和 rbind()，或者 dplyr 包的 bind_cols()函数和 bind_rows()函数实现该功能。先构造 3 个数据框如下：</p><pre class="line-numbers language-R"><code class="language-R">df1<-data.frame(x= c("a","b","c"), y=1:3)df2<- data.frame(z= c("B","D","H"), g =c(2,5,3))df3<- data.frame(x= c("g","d"), y =c(2,5))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（1）数据框添加列或者横向添加表格：</p><pre class="line-numbers language-R"><code class="language-R">dat_cbind<-cbind(df1,df2) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（2）数据框添加行或者纵向添加表格：</p><pre class="line-numbers language-R"><code class="language-R">dat_rbind<-rbind(df1,df3)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><font color="purple"> <strong>此处插入图片</strong></font></p><h3 id="2-2-2表格的融合"><a href="#2-2-2表格的融合" class="headerlink" title="2.2.2表格的融合"></a>2.2.2表格的融合</h3><p>有时，两个数据框并没有很好地保持一致，不能简单地使用 cbind()函数或 rbind()函数直接拼接。所以它们<strong>需要一个共同的列（common key）作为融合的依据。</strong>在表格的融合中，最常用的函数是R内置函数 merge()和 dplyr 包的*_join()系列函数。我们首先构造 4 个数据框，如下：</p><pre class="line-numbers language-R"><code class="language-R">df1<-data.frame(x= c("a","b","c"), y=1:3)df2<- data.frame(x= c("a","b","d"), z =c(2,5,3))df3<- data.frame(g= c("a","b","d"), z =c(2,5,3))df4<- data.frame(x= c("a","b","d"), y=c(1,4,2),z =c(2,5,3))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><font color="purple"> <strong>此处插入图片</strong></font></p><p>（1）merge()函数</p><p>其优势在于对每个数据框可以指定不同的匹配列名；缺点在于运行速度比较慢。其中，by.x 是指左边数据框的匹配列，by.y 是指右边数据框的匹配列。</p><pre class="line-numbers language-R"><code class="language-R">dat_merge1 <-merge(df1,df2,by="x", all = TRUE) dat_merge2 <-merge(df1,df3,by.x="x",by.y="g") dat_merge3 <-merge(df1,df4,by=c("x","y"), all = TRUE) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>效果如下所示</p><p><font color="purple"> <strong>此处插入图片</strong></font></p><p>（2）*_join()系列函数</p><p>dplyr 包提供了 left_join()、 right_join()、inner_join()和 full_ join()四个函数，可以实现不同的表格融合效果。其中，full_ join()函数主要用来生成两个集合的并集；inner_join()函数通常用来生成有效的数据；left_join()函数和 right_join()函数使用的场景偏少。另外，两个表格融合时会用 NA（缺失 值）代替不存在的值。</p><ul><li>只保留左表的所有数据：</li></ul><pre class="line-numbers language-R"><code class="language-R">dat_join1 <-dplyr::left_join (x=df1,y=df2,by="x")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>只保留右表的所有数据：</li></ul><pre class="line-numbers language-R"><code class="language-R">dat_join2 <-dplyr::right_join (x=df1,y=df2,by= "x")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>只保留两个表中公共部分的信息：</li></ul><pre class="line-numbers language-R"><code class="language-R">dat_join3 <-dplyr::inner_join (x=df1,y=df2,by="x")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>保留两个表的所有信息：</li></ul><pre class="line-numbers language-R"><code class="language-R">dat_join4 <-dplyr:: full_join(x=df1,y=df2,by="x")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><font color="purple"> <strong>此处插入图片</strong></font></p><ul><li>by=c(“x”,”y”)表示多列匹配：</li></ul><pre class="line-numbers language-R"><code class="language-R">dat_join5 <-dplyr::left_join (x=df1,y=df4,by= c("x","y"))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>by=c(“x”=”g”)可以根据两个表的不同列名合并：</li></ul><pre class="line-numbers language-R"><code class="language-R">dat_join6 <-dplyr::left_join (x=df1,y=df3,by= c("x"="g"))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>如果与表合并的过程中遇到有一列在两个表中同名，但是值不同，合并的时候又都想保留下来，就可以用 suffix 给每个表的重复列名增加后缀：</li></ul><pre class="line-numbers language-R"><code class="language-R">dat_join7<-dplyr::left_join (x=df1,y=df4,by="x", suffix=c(".1",".2"))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>R语言实战</title>
      <link href="/2022/05/11/r-yu-yan-shi-zhan/"/>
      <url>/2022/05/11/r-yu-yan-shi-zhan/</url>
      
        <content type="html"><![CDATA[<h2 id="一、R语言编程与绘图基础"><a href="#一、R语言编程与绘图基础" class="headerlink" title="一、R语言编程与绘图基础"></a>一、R语言编程与绘图基础</h2><h3 id="1、R语言编程基础"><a href="#1、R语言编程基础" class="headerlink" title="1、R语言编程基础"></a>1、R语言编程基础</h3><h4 id="1-1数据类型"><a href="#1-1数据类型" class="headerlink" title="1.1数据类型"></a>1.1数据类型</h4><p>R中常见的数据类型为数值型（numeric）、字符型（character）、日期型（date）、逻辑型（logical），变量的数据类型都可以用class()函数查看</p><ul><li><p>数值型</p><pre class="line-numbers language-R"><code class="language-R">a<- 1;is.numeric(a)#输出判定a是否为数值型：TRUE<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>字符型</p><pre class="line-numbers language-R"><code class="language-R">b<- "peter"; nchar(b)#输出字符串的长度<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>日期型</p><p>最常用的日期型数据类型是Date（进存储日期）和POSIXct（同时存储日期和时间）</p><pre class="line-numbers language-R"><code class="language-R">c<-as.Date("2012-06-12");class(c)#输出c的类型为Dated<-as.POSIXct（"2012-06-12 17:32"）; class(d) #输出 d 的数据类型为："POSIXct" "POSIXt"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>逻辑型</p><pre class="line-numbers language-R"><code class="language-R">e<-TRUE, f<-FALSE<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，在处理时序数据时，我们需要处理日期型数据，往往需要使用 as.Date()函数将读入的数据从数值型转换成日期型，有时候还需要进一步提取日期型数据的年、月、周等数据信息。此时我 们需要使用 as.numeric()函数或者 as.integer()函数将日期型数据转换成数值型。其中，strftime(x, format  = “”)函数可以定义日期型数据的格式，比如 strftime(c, ‘%Y’)表示只显示年份。</p><pre class="line-numbers language-R"><code class="language-R">c_Year<- as.integer(strftime(c, '%Y')) #输出年份：2012 c_month <- as.integer(strftime(c, '%m')) #输出月份：6 c_week<- as.integer(strftime(c, '%W')) #输出周数：24<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="1-2数据结构"><a href="#1-2数据结构" class="headerlink" title="1.2数据结构"></a>1.2数据结构</h4><p>常见的数据结构包括：<strong>向量（vector）</strong>、<strong>数据框（data.frame）</strong>、<strong>矩阵（matrix）</strong>、<strong>列表（list）</strong>和<strong>数组（array）</strong>。其中，矩阵是将数据用行和列排列的长方形表格，<strong>矩阵是二维数组，<em>其单元必须是相同的数据类型</em></strong>，通常用列来表示不同的变量，用行表示各个对象；<strong>数组可以看作是带有多个下标的类型 相同的元素的集合</strong>；列表是一个对象的有序集合构成的对象，列表中包含的对象又称为它的分量 （component），分量可以是不同的模式或（和）类型。我们在本书的<strong>数据可视化中，比较常用的是向量（因子属于特殊的向量）和数据框</strong>，所以我们重点介绍这两种类型的数据结构，还将介绍与数据可视化密切相关的函数。</p><h5 id="1-2-1向量"><a href="#1-2-1向量" class="headerlink" title="1.2.1向量"></a>1.2.1向量</h5><p>向量是用于存储数值型、字符型或逻辑型数据的一维数组。执行组合功能的函数 c()可用来创建 向量（c 代表合并：combine）。值得注意的是，<strong>单个向量中的数据类型是固定的</strong>，比如数值型向量中的元素就必须全为向量。向量是 R 语言中最基本的数据结构, 其他类型的数据结构都可以由向量构 成。最常见的向量有三种类型：数值型、字符型、逻辑型。</p><p><strong>（1）向量的创建</strong></p><p>向量的创建有多种方法，我们既可以手动输入，使用函数 c()创建向量；也可以使用现有的函数 创建向量，比如 seq()、rep()等函数</p><table><thead><tr><th align="center">输入</th><th align="center">输出</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">c(2,4,6)</td><td align="center">2 4 6</td><td align="center">将元素连接成向量</td></tr><tr><td align="center">2:6</td><td align="center">2 3 4 5 6</td><td align="center">等差整数数列</td></tr><tr><td align="center">seq(2, 3, by=0.5)</td><td align="center">2.0 2.5 3.0</td><td align="center">步长为 0.5 的等差数列</td></tr><tr><td align="center">rep(1:2, times=3)</td><td align="center">1 2 1 2 1 2</td><td align="center">将一个向量重复 3 次</td></tr><tr><td align="center">rep(1:2, each=3)</td><td align="center">1 1 1 2 2 2</td><td align="center">将一个向量中的每个元素重复 3 次</td></tr><tr><td align="center">rnorm(3, mean = 0, sd = 3)</td><td align="center">0.3823209 1.3203584 3.1263230</td><td align="center">均值为 0、标准差为 3 的正态分布</td></tr><tr><td align="center">runif(3, min = 0, max = 1)</td><td align="center">0.9552905 0.6813195 0.4527798</td><td align="center">最大值为 1、最小值为 0 的均匀分布</td></tr><tr><td align="center">sample(c(“A”,”B”,”C”), 4, replace=TRUE)</td><td align="center">“A” “A” “A” “B”</td><td align="center">从一个向量中随机抽取</td></tr></tbody></table><p><strong>（2）向量的处理</strong></p><ul><li><p>向量的排序</p><p>很多时候我们需要先对数据进行降序处理，再展示数据 。 sort() 函数可以实现对向量的排序处理，index.return=TRUE，表示返回排序的索引；decreasing = TRUE，表示降序处理。</p><pre class="line-numbers language-R"><code class="language-R">Vec<-c(1,4,3,5,2)order<-sort(Vec, index.return=TRUE,decreasing = TRUE)输出结果为：$x 为[5 4 3 2 1]，$ix 为[4 2 3 5 1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>向量的唯一值</p><p>unique()函数主要是返回一个删除了重复元素或行的向量、数据框或数组。在需要对数据框根据某列进行分组运算时，需要使用该函数先获取类别总数。</p><pre class="line-numbers language-R"><code class="language-R">Vec<-c("peter","jack","peter","jack","eelin")Uni<-unique(Vec) #输出："peter", "jack", "eelin"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>连续向量的离散化</p><p>有时需要把连续型变量转换为离散型变量， 这种转换的过程就是<strong>数据离散化</strong>，<strong>分箱</strong>就是离散化常用的一种方法。数据离散化最简单的方法就是使用 cut()函数自定义离散区间，从而对数据进行离散处理。</p><pre class="line-numbers language-R"><code class="language-R">Num_Vector<- c(10, 5, 4, 7, 6, 1, 4, 8, 8, 5)Cut_Vector<-cut(Num_Vector,breaks=c(0,3,6,9,11), labels=c("0~3", "3~6", "6~9", ">9"), right = TRUE)#输出结果为因子向量：>9, 3~6, 3~6, 6~9, 3~6, 0~3, 3~6, 6~9, 6~9, 3~6；其水平 Levels 为: 0~3, 3~6, 6~9, >9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>（3）向量的索引</strong></p><p>向量是多个元素的集合，当我们只需要指定或者说提取该向量中的某个元素时，就可以使用向量的索引（indexing）。向量元素有三种基本类型的向量索引：<strong>整数型</strong>，索引的是元素位置；<strong>字符型</strong>， 索引的是名称属性；<strong>逻辑型</strong>，索引的是相同长度的逻辑向量对应的逻辑值为真的元素。</p><pre class="line-numbers language-R"><code class="language-R">x<-c(1,4,3,5,2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>整数型索引，选择某个或多个元素：x[2]; x[-2]; x[2:4]; x[c(1,4)]</li><li>逻辑型索引，逻辑运算选择元素：x[x&gt;2]; x[x==1]; x[x&lt;=5]</li></ul><h6 id="1-2-2因子"><a href="#1-2-2因子" class="headerlink" title="1.2.2因子"></a>1.2.2因子</h6><p>因子（factor）是 R 语言中许多强大运算的基础，包括许多针对表格数据的运算，可分为类别型变量和有序型变量。因子可以看成是<strong>包含了额外信息的向量</strong>，这额外的信息就是不同的类别，称之为水平（level）。因子在 R 中非常重要，因为它决定了数据的分析方式，以及如何进行视觉呈现。</p><p><strong>（1）因子的创建</strong></p><p>一个因子不仅包括分类变量本身，还包括变量不同的可能水平（即使它们在数据中不出现）。因 子函数 factor()用下面的选项创建一个因子。对于字符型向量，因子的水平默认依字母顺序创建:</p><pre class="line-numbers language-R"><code class="language-R">(Fair,Good, Ideal, Premium, Very Good)Cut<-c("Fair","Good","Very Good","Premium","Ideal") Cut_Facor1<-as.factor(Cut)#以下为输出结果#[1] Fair      Good      Very Good Premium   Ideal    #Levels: Fair Good Ideal Premium Very Good<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>（2）水平的更改</strong></p><p>可以指定 levels 选项来覆盖默认排序（按默认是以字母顺序排序）。更改因子向量的 levels 为(“Good”,”Fair”,”Very Good”,”Ideal”,”Premium”)，就需要使用 factor()函数更改 levels。</p><pre class="line-numbers language-R"><code class="language-R">Cut_Facor2<-factor(x=c("Fair","Good","Very Good","Premium","Ideal"), levels= c("Good","Fair","Very Good","Ideal","Premium"),  ordered=TRUE)#以下为输出结果#[1] Fair      Good      Very Good Premium   Ideal    #Levels: Good < Fair < Very Good < Ideal < Premium<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>（3）类型的转换</strong></p><p>数值型因子向量的类型变换。有时候需将数值型的因子向量重新转换成数值型向量，这时，需要使用 as.numeric(as.character())组合函数，而不能直接使用 as.numeric()函数。其中 as.character() 函数表示将向量变成字符型，as.numeric()函数表示将向量变成数值型。</p><pre class="line-numbers language-R"><code class="language-R">Num _Facor<-factor(x=c(1,3,5,2), levels= c(5,3,2,1), ordered=TRUE) Num_Vector1<-as.numeric(as.character(Num_Facor)) # 输出：1 3 5 2Num_Vector2<-as.numeric(Num_Facor) # 输出：4 2 1 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="1-2-3数据框"><a href="#1-2-3数据框" class="headerlink" title="1.2.3数据框"></a>1.2.3数据框</h5><p>数据框是 R 语言中的一种表格结构，数据框是由多个向量构成的，每个向量的长度相同。数据框类似矩阵，也是一个二维表结构。在统计学术语中，用行来表示观测（observation），用列来表示变量（variable）。</p><p><strong>（1）数据框的创建与查看</strong></p><p>创建数据框，最简单的方法就是，用同名的定义函数 data.frame()，输入每个变量的名称及对应的向量，每个向量的长度相同。一个数据框可能包含多个变量（向量），有时需要单独提取某个变量， 使用特殊的$符号来访问，由“数据框$变量名”构成。</p><ul><li>获取数据框的行数、列数和维数：nrow()、ncol()、dim()。</li><li>获取数据框的列名或行名：names()、rownames()、colnames()；重新定义列名：names(df)&lt;-c(“X”,  “Y”, “Z”)。</li><li>观察数据框的内容：view(df)、head(df, n=3)、tail(df)。</li></ul><p><strong>（2）空数据框的创建</strong></p><p>创建空数据框，在需要自己构造绘图的数据框数据信息时尤为重要。有时，在绘制复杂的数据图表的过程中，我们需要对现有数据进行插值、拟合等处理，这时需要使用空的数据框存储新的数据，最后使用新的数据框绘制图表。创建空的数据框主要有如下两种方法。</p><ul><li>创建一个名为 Df_Empty，包括两个变量（var_a 为 numeric 类型；var_b 为 character 类型）的 data.frame。但是注意：要加上 stringsAsFactors=FALSE，否则在后面逐行输入数据时，会因 为 var_b 的取值未经定义的 factor level 而报错。</li></ul><pre class="line-numbers language-R"><code class="language-R">Df_Empty1<- data.frame(var_a = numeric(),var_b = character(),stringsAsFactors=FALSE)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>先使用矩阵创建空的数据框，同时通过 dimnames 设定数据框的列名。这个相比前一种方法 可以更快速地创建多列空数据框：</p><pre class="line-numbers language-R"><code class="language-R">Df_Empty2 <- data.frame(matrix(ncol=2, nrow=0,dimnames=list(c(),c("var_a","var_b"))))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="1-3数据属性"><a href="#1-3数据属性" class="headerlink" title="1.3数据属性"></a>1.3数据属性</h4><p>数据框作为 R 语言数据分析与可视化很常用的数据结构，常由多列不同数据属性的变量组成。 在我们实现数据可视化时，很有必要先了解这些变量的属性。Jiawei Han 等人的 Data mining: concepts and techniques根据数据属性取值的集合类型，将数据属性分成了三类：类别型、序数型和数值型。</p><h5 id="1-3-1类别型"><a href="#1-3-1类别型" class="headerlink" title="1.3.1类别型"></a>1.3.1类别型</h5><p>类别型属性（categorical attribute）是用于区分不同数据对象的符号或名称，而它们是没有顺序关系的，又包含多元类别和二元类别两种类型。对于多元类别，可以理解为购买服装时的不同服装名称，如衬衫、毛衣、T 恤、夹克等；对于二元类别，可以理解为购买服装时的不同性别，只有男士和女士两种性别分类。</p><h4 id="1-4数据的导入与输出"><a href="#1-4数据的导入与输出" class="headerlink" title="1.4数据的导入与输出"></a>1.4数据的导入与输出</h4><h4 id="1-5控制语句与函数编写"><a href="#1-5控制语句与函数编写" class="headerlink" title="1.5控制语句与函数编写"></a>1.5控制语句与函数编写</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/10/hello-world/"/>
      <url>/2022/05/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
