<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>R4DS读书笔记（第二章、工作流：基础）</title>
      <link href="/2022/05/19/r4ds-du-shu-bi-ji-di-er-zhang-gong-zuo-liu-ji-chu/"/>
      <url>/2022/05/19/r4ds-du-shu-bi-ji-di-er-zhang-gong-zuo-liu-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="代码基础"><a href="#代码基础" class="headerlink" title="代码基础"></a>代码基础</h2><p>创建对象使用下列的形式</p><pre class="line-numbers language-R"><code class="language-R">object_name <- value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Rstudio中常使用“alt+减号”生成赋值符号“&lt;-”</p><h2 id="对象名称"><a href="#对象名称" class="headerlink" title="对象名称"></a>对象名称</h2><p>使用对象名不能有错误，区分大小写，需要严格准确，在rstudio里输入this,使用按 Ctrl+ ↑可查询所有使用了以“this”为前缀的命令。</p><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>内置函数的调用方式如下：</p><pre class="line-numbers language-R"><code class="language-R">function_name(arg1 = val1, arg2 = val2, ...)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用tab键帮助预测下一步命令、使用↑和↓箭头键来选择命令，自动补齐命令。注意弹出的浮动提示信息，它可以告诉你这个函数的参数和作用。如果想要获得更多帮助，按 F1 键就可以在右下角窗格的帮助标签页中看到详细的帮助信息。</p><p>引号和括号必须一直成对出现。RStudio 会尽力帮助我们，但如果出现不匹配，R 会显示一个 + 号提示R 在等待继续输入。</p><p>如果进行了一次赋值，R 不会显示出赋值结果。你最好立刻打印出来检查一下：</p><pre class="line-numbers language-R"><code class="language-R">y <- seq(1, 10, length.out = 5)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -R语言 -数据可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R4DS读书笔记（第一章、使用ggplot2数据可视化）</title>
      <link href="/2022/05/18/r4ds-du-shu-bi-ji-di-yi-zhang-shi-yong-ggplot2-shu-ju-ke-shi-hua/"/>
      <url>/2022/05/18/r4ds-du-shu-bi-ji-di-yi-zhang-shi-yong-ggplot2-shu-ju-ke-shi-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="R4DS读书笔记（第一章、使用ggplot2数据可视化）"><a href="#R4DS读书笔记（第一章、使用ggplot2数据可视化）" class="headerlink" title="R4DS读书笔记（第一章、使用ggplot2数据可视化）"></a>R4DS读书笔记（第一章、使用ggplot2数据可视化）</h1><p>最近在啃Hadley Wickham大佬的经典著作，R4DS（R for Data Science，中译本：R数据科学），经典的数据科学的项目分析应当遵循以下流程，而作者将最精彩的部分也就是数据可视化内容前置，让我们率先获得学习R语言之后可以用来干什么，能做出什么样的图表。<img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E6%B5%81%E7%A8%8B%E5%9B%BE1.png"></p><pre class="line-numbers language-R"><code class="language-R">install.packages("tidyverse")#安装tidyverse这个packagelibrary(tidyverse)#加载tidyverse这个package#如果想调用某个包里的具体函数，可使用以下语法结构：package::function()#例如ggplot2::ggplot()就是调用ggplot2包中的ggplot函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><h3 id="引入mpg数据框"><a href="#引入mpg数据框" class="headerlink" title="引入mpg数据框"></a>引入mpg数据框</h3><p>使用ggplot2包中自带的mpg数据框，在console里输入mpg，可展示mpg数据的相关信息（234行观测*11列变量的数据框）</p><h3 id="创建ggplot图形"><a href="#创建ggplot图形" class="headerlink" title="创建ggplot图形"></a>创建ggplot图形</h3><pre class="line-numbers language-R"><code class="language-R">ggplot(data=mpg)+    geom_point(mapping = aes(x=displ,y=hwy))#ggplot(data=mpg) ggplot() 函数创建了一个坐标系，可以在上面添加图层，ggplot(data = mpg)创建一张空白图#函数 geom_point() 向图中添加一个点层，这样就可以创建一张散点图#ggplot2中的每个几何对象函数都有一个 mapping参数。mapping参数总是与aes()函数成对出现，aes()函数的x参数和y参数分别指定了映射到x轴的变量与映射到y轴的变量。ggplot2在data参数中寻找映射变量，本例中就是mpg。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE1.png"></p><h3 id="使用ggplot绘图的语法模板"><a href="#使用ggplot绘图的语法模板" class="headerlink" title="使用ggplot绘图的语法模板"></a>使用ggplot绘图的语法模板</h3><pre class="line-numbers language-R"><code class="language-R">ggplot(data = <DATA>) + <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))#由上面我们可以抽象出ggplot绘图的语法模板<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="图形的属性映射"><a href="#图形的属性映射" class="headerlink" title="图形的属性映射"></a>图形的属性映射</h2><p>可以向二维散点图中添加<strong>第三个变量</strong>，比如 class，方式是将它<strong>映射为图形属性</strong>。<strong>图形属性是图中对象的可视化属性，其中包括数据点的大小、形状和颜色。</strong>通过改变图形属性的值，可以用不同的方式来显示数据点。</p><pre class="line-numbers language-R"><code class="language-R">#将点的颜色映射为变量 class，从而揭示每辆汽车的类型ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = class))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%BD%B1%E5%83%8F2.png"></p><p>除了将class映射为颜色外，还可将其映射为点的大小，但此时会收到一条warning ‘Using size for a discrete variable is not advised’，将无序变量（class）映射为有序图形属性（size）不是一个很好的建议。<img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE2.png"></p><p>此外我们还可以将class映射为控制数据点<strong>透明度</strong>的alpha图形属性，也可映射为<strong>点的形状</strong></p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, alpha = class))#这里同样给出了warning：Using alpha for a discrete variable is not advised<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE3.png"></p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, shape = class))#这里同样给出了warning：1: The shape palette can deal with a maximum of 6 discrete values because more than 6 becomes difficult to discriminate; you have 7. Consider specifying shapes manually if you must have them. 2: Removed 62 rows containing missing values (geom_point)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE4.png"></p><p>默认情况下，ggplot2 只能同时使用 6 种形状，多出的变量值将不会出现在图中。</p><p>此外，我们还可以<strong>手动为几何对象设置图形属性</strong>，例如让所有的点都是<font color="blue">蓝色</font>:</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data=mpg)+    geom_point(mapping= aes(x=displ,y=hwy),color="blue")#手动设置图形属性，为几何对象函数的一个参数,需要在函数 aes() 的外部进行设置。#写代码的时候要注意，+号应放在每一行的末尾而不是开头<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE5.png"></p><h2 id="分面"><a href="#分面" class="headerlink" title="分面"></a>分面</h2><p>添加额外变量的一种方法是使用图形属性。另一种方法是<strong>将图分割成多个分面</strong>，即可以显示数据子集的子图。这种方法特别适合添加分类变量。使用函数 facet_wrap()通过单个变量对图进行分面，第一个参数是一个公式，创建公式的方式是在 ~ 符号后面加一个变量名，<strong>传递给 facet_wrap() 的变量应该是离散型的</strong></p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_wrap(~ class, nrow = 2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE6.png"></p><p>通过两个变量对图进行分面，需要在绘图命令中加入函数 facet_grid()。这个函数的 第一个参数也是一个公式，但该公式包含由 ~ 隔开的两个变量名。</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_grid(drv ~ cyl)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE7.png"></p><p>如果不想在行或列的维度进行分面，你可以使用 . 来代替变量名，例如 + facet_grid(. ~  cyl)</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_grid(.~ cyl)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE8.png"></p><h2 id="几何对象"><a href="#几何对象" class="headerlink" title="几何对象"></a>几何对象</h2><p><strong>几何对象是图中用来表示数据的几何图形对象。</strong>可以使用不同的几何对象来表示同样的数据。如下图，左侧的图使用了点几何对象，右侧的图使用了平滑曲线几何对象，以一条平滑曲线来拟合数据。</p><pre class="line-numbers language-R"><code class="language-R"># 左图ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy))# 右图ggplot(data = mpg) + geom_smooth(mapping = aes(x = displ, y = hwy))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE9.png"></p><p>我们无法设置线的形状，但是可以通过linetype设置线型</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg) + geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv))#一条线表示 drv 值为 4 的所有汽车，一条线表示 drv 值为 f 的所有汽车，另一条线表示 drv 值为 r 的所有汽车。其中 4 表示四轮驱动，f 表示前轮驱动，r 表示后轮驱动<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE10.png"></p><p>只要将一个图形属性映射为一个离散变量（如上个示例中的 linetype），ggplot2 就会自动对数据进行分组来绘制多个几何对象。</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg) + geom_smooth( mapping = aes(x = displ, y = hwy, color = drv), show.legend = FALSE )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE11.png"></p><p>此外，可以将这些几何对象的 group 图形属性设置为一个分类变量，这样 ggplot2 就会为这个分类变量的每个唯一值绘制一个独立的几何对象。</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg) + geom_smooth(mapping = aes(x = displ, y = hwy, group = drv))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE12.png"></p><p><strong>如果在同一张图中显示多个几何对象，可以向 ggplot() 函数中添加多个几何对象函数：</strong></p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + geom_smooth(mapping = aes(x = displ, y = hwy))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE13.png"></p><p>但是这么写代码的话，会显得很罗嗦，每次要往空白图上添加一次几何对象，就得重复一次aes(x=?,y=?)。<strong>避免重复的方法是将一组映射直接传递给 ggplot() 函数，ggplot2 会将这些映射作为全局映射应用到图中的每个几何对象中,下面的代码与上面的代码效果一致</strong></p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point() + geom_smooth()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果将映射放在几何对象函数中，那么 ggplot2 会将其看作这个图层的局部映射，它将使用这些映射扩展或覆盖全局映射，但仅对该图层有效。这样一来，我们就可以在不同的图层中显示不同的图形属性：</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point(mapping = aes(color = class)) + geom_smooth()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE14.png"></p><p>同理，为不同的图层可以分别指定不同的数据</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point(mapping = aes(color = class)) + geom_smooth(color="green")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE15.png"></p><h2 id="统计变换"><a href="#统计变换" class="headerlink" title="统计变换"></a>统计变换</h2><p>使用基本的geom_bar() 函数可绘制基本的条形图，diamonds 数据集是 ggplot2 的内置数据集，大约包含 54 000 颗钻石的信息，每颗钻石具有 price、carat、color、 clarity 和 cut 变量。</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut))#按照 cut 变量分组的各种钻石的总数量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE16.png"></p><p>前面的散点图是用来描绘数据集已有原始数据信息的。但是y轴上的count不是diamonds的变量，这里描述产生的新数据使用的是条形图。</p><ul><li><p>条形图、直方图和频率多边形图可以对数据进行分箱（<strong>数据分箱操作</strong>），然后绘制出分箱数量和落在每个分箱的数据点的数量。</p></li><li><p>平滑曲线会为数据拟合一个模型，然后绘制出<strong>模型预测值</strong>。</p></li><li><p>箱线图可以计算出数据分布的多种摘要统计量（<strong>计算多种统计量</strong>），并显示一个特殊形式的箱体。</p></li></ul><p>绘图时用来<strong>计算新数据的算法称为 stat（statistical transformation，统计变换）</strong>。</p><p>通常来说，几何对象函数和统计变换函数可以互换使用。例如，你可以使用 stat_count() 替换 geom_bar() 来重新生成前面那张图：</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = diamonds) + stat_count(mapping = aes(x = cut))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>显式使用某种统计变换的 3 个原因如下:</p><ul><li><p>覆盖默认的统计变换。在以下代码中，将 geom_bar() 函数的统计变换从计数（默认值）修改为标识。这样就可以将条形的高度映射为 y 轴变量的初始值。</p><pre class="line-numbers language-R"><code class="language-R">demo <- tribble( ~a, ~b, "bar_1", 20, "bar_2", 30, "bar_3", 40)ggplot(data = demo) + geom_bar( mapping = aes(x = a, y = b), stat = "identity" )#不同于前面计数才能生成数据，条形图高度数据已经存在于数据集中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot.png"></p></li><li><p>覆盖从统计变换生成的变量到图形属性的默认映射。例如，你或许想显示一 张表示比例（而不是计数）的条形图：</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = diamonds) + geom_bar( mapping = aes(x = cut, y = ..prop.., group = 1) )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE17.png"></p><ul><li><p>想要在代码中强调统计变换。例如，你可以使用 stat_summary() 函数将人们的注意力吸引到你计算出的那些摘要统计量上。stat_summary() 函数为 x 的每个唯一值计算 y 值的摘要统计：</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = diamonds) + stat_summary( mapping = aes(x = cut, y = depth), fun.ymin = min, fun.ymax = max, fun.y = median)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="位置调整"><a href="#位置调整" class="headerlink" title="位置调整"></a>位置调整</h2><p>在这里，条形图可使用使用color或者fill来上色，下面展示两者的不同</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, color = cut))ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = cut))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot01.png" style="zoom:80%;" align="center"><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot02.png" style="zoom:80%;" align="center"><p><strong>注意，如果将 fill 图形属性映射到另一个变量（如 clarity），那么条形会自动分块堆叠起来。每个彩色矩形表示 cut 和 clarity 的一种组合。</strong></p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = clarity))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot03.png"></p><p>这种堆叠是由 position 参数设定的位置调整功能自动完成的。如果不想生成堆叠式条形图，你还可以使用以下 3 种选项之一：”identity”、”fill” 和 “dodge”。</p><ul><li><p>position = “identity” 将每个对象直接显示在图中。这种方式不太适合条形图，因为 条形会彼此重叠。为了让重叠部分能够显示出来，我们可以设置 alpha 参数为一个较小 的数，从而使得条形略微透明；或者设定 fill = NA，让条形完全透明：</p><pre class="line-numbers language-R"><code class="language-R">ggplot( data = diamonds, mapping = aes(x = cut, fill = clarity)) + geom_bar(alpha = 1/5, position = "identity")ggplot( data = diamonds, mapping = aes(x = cut, color = clarity)) + geom_bar(fill = NA, position = "identity")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot04.png"></p></li><li><p>position = “fill” 的效果与堆叠相似，但每组堆叠条形具有同样的高度，因此这种条形图可以非常轻松地比较各组间的比例：</p><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot05.png"></p></li><li><p>position = “dodge” 将每组中的条形依次并列放置，这样可以非常轻松地比较每个条形表示的具体数值：</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = diamonds) + geom_bar( mapping = aes(x = cut, fill = clarity), position = "dodge" )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot06.png"></p></li></ul><p>此外还有一种关于散点图的位置调整，在一个网格上，很多点彼此重叠。这个问题称为<strong>过绘制</strong>。通过将位置调整方式设为“抖动”，可以避免这种网格化排列。position = “jitter” 为每个数据点添加一个很小的随机扰动，这样就可以将重叠的点分散开来</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg) + geom_point( mapping = aes(x = displ, y = hwy), position = "jitter" )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot07.png" style="zoom:80%;" align="center"><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot08.png" style="zoom:80%;" align="center"><h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><p>默认坐标系是笛卡儿直角坐标系，可以通过其 独立作用的 x 坐标和 y 坐标找到每个数据点。</p><ul><li><p>coord_flip() 函数可以交换 x 轴和 y 轴。当想要绘制水平箱线图时，这非常有用。它也非常适合使用长标签，但要想在 x 轴上不重叠地安排好它们是非常困难的：</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + geom_boxplot()ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + geom_boxplot() + coord_flip()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot09.png" style="zoom:80%;" align="center"><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot10.png" style="zoom:80%;" align="center"></li><li><p>coord_quickmap() 函数可以为地图设置合适的纵横比。当使用 ggplot2 绘制空间数据时， 这个函数特别重要。</p><pre class="line-numbers language-R"><code class="language-R">nz <- map_data("nz")ggplot(nz, aes(long, lat, group = group)) + geom_polygon(fill = "white", color = "black")ggplot(nz, aes(long, lat, group = group)) + geom_polygon(fill = "white", color = "black") + coord_quickmap()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot11.png" style="zoom:80%;" align="center"><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot12.png" style="zoom:80%;" align="center"></li><li><p>coord_polar() 函数使用极坐标系。极坐标系可以揭示出条形图和鸡冠花图间的一种有趣联系：</p><pre class="line-numbers language-R"><code class="language-R">bar <- ggplot(data = diamonds) + geom_bar( mapping = aes(x = cut, fill = cut), show.legend = FALSE, width = 1 ) + theme(aspect.ratio = 1) + labs(x = NULL, y = NULL)bar + coord_flip()bar + coord_polar()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot13.png" style="zoom:80%;" align="center"><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot14.png" style="zoom:80%;" align="center"></li></ul><h2 id="图形分层语法"><a href="#图形分层语法" class="headerlink" title="图形分层语法"></a>图形分层语法</h2><p>通过前面的绘制散点图、条形图和箱线图，我们掌握了使用 ggplot2 绘制任何类型图形的基础知识。</p><p>这里我们给出在前面的代码模板中添加位置调整、统计变换、坐标系和分面，给出一般情况下的使用ggplot2绘图的语法模板</p><pre class="line-numbers language-R"><code class="language-R"># ggplot(data = <<data>>) +# <<GEOM_FUNCTION>>(# mapping = aes(<<MAPPINGS>>),# stat = <<STAT>>,# position = <<POSITION>># ) +# <<COORDINATE_FUNCTION>> +# <<FACET_FUNCTION>><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新模板有 7 个参数，即模板中尖括号内的部分。但实际上，绘图时几乎不需要提供所有的 7 个参数，因为除了数据、映射和几何对象函数，ggplot2 为所有其他参数提供了非常有用的默认设置。</p><p><strong>将任何图形精确地描述为数据集、几何对象、映射集合、统计变换、位置调整、坐标系和分面模式的一个组合，图形语法正是基于这样的深刻理解构建出来的。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
            <tag> 数据可视化 </tag>
            
            <tag> ggplot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建博客杂谈</title>
      <link href="/2022/05/11/da-jian-bo-ke-za-tan/"/>
      <url>/2022/05/11/da-jian-bo-ke-za-tan/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建博客杂谈"><a href="#搭建博客杂谈" class="headerlink" title="搭建博客杂谈"></a>搭建博客杂谈</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>坦白说，这次注册的域名的命名确实有玩梗的成分在：<a href="https://flying2the.top/">https://flying2the.top</a> （当然也是方便记忆了）</p><h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p>本地安装<a href="https://nodejs.org/en/">Node.js (nodejs.org)</a></p><p>进入本地终端，使用下列命令检查是否安装成功</p><pre class=" language-shell"><code class="language-shell">node -vnpm -vnpm config set registry https://registry.npm.taobao.org #添加国内镜像源</code></pre><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>本地安装<a href="https://git-scm.com/downloads">Git - Downloads (git-scm.com)</a></p><p>进入终端，检验git是否正确安装：</p><pre class=" language-shell"><code class="language-shell">git --version</code></pre><h2 id="注册GitHub账号，创建一个新repo"><a href="#注册GitHub账号，创建一个新repo" class="headerlink" title="注册GitHub账号，创建一个新repo"></a>注册GitHub账号，创建一个新repo</h2><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/repo.png"></p><p>选择GitHub pages主题</p><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/theme.png"></p><h2 id="本地安装hexo"><a href="#本地安装hexo" class="headerlink" title="本地安装hexo"></a>本地安装hexo</h2><p>新建一个blog文件夹，该目录下右键点击<code>Git Bash Here</code>，打开git的shell，输入<code>npm i hexo-cli -g</code>安装Hexo，</p><p>安装完后输入<code>hexo -v</code>验证是否安装成功，输入<code>hexo init</code>初始化文件夹，接着输入<code>npm install</code>安装必备的组件。</p><p>最常用的几个命令：</p><pre class=" language-shell"><code class="language-shell">hexo g #本地buildhexo s #本地启动服务，可通过本地的4000端口预览hexo d #deploy到GitHub服务器上</code></pre><h2 id="本地生成密钥"><a href="#本地生成密钥" class="headerlink" title="本地生成密钥"></a>本地生成密钥</h2><p>注册自有的Github账号，右键打开git bash，然后输入下面命令：</p><pre class=" language-shell"><code class="language-shell">git config --global user.name "GuoYu2022"git config --global user.email "yg9655@icloud.com"</code></pre><p>然后生成密钥SSH key：</p><pre class=" language-shell"><code class="language-shell">ssh-keygen -t rsa -C "yg9655@icloud.com"</code></pre><p>GitHub的设置里面新建一个SSH，在bash中输入</p><pre class=" language-shell"><code class="language-shell">cat ~/.ssh/id_rsa.pub</code></pre><p>将读取出的密钥信息复制到GitHub的SSH里面</p><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-05-11%20143240.png"></p><p>输入<code>ssh -T git@github.com</code>，如果出现用户名，说明已经成功</p><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/1.png"></p><h2 id="执行Hexo-d报错Spawn-failed，-以及OpenSSL-SSL-read-Connection-was-reset-errno-10054"><a href="#执行Hexo-d报错Spawn-failed，-以及OpenSSL-SSL-read-Connection-was-reset-errno-10054" class="headerlink" title="执行Hexo d报错Spawn failed， 以及OpenSSL SSL_read: Connection was reset, errno 10054"></a><font color="red"><strong>执行Hexo d报错Spawn failed， 以及OpenSSL SSL_read: Connection was reset, errno 10054</strong></font></h2><p>在部署时报了这样的错误，解决方法如下</p><pre class=" language-shell"><code class="language-shell">ssh git@github.com #首先检测SSH密钥是否有效hexo config deploy.repository git@github.com:GuoYu2022/GuoYu2022.github.io.git # 参考这一句解决hexo config deploy.repository git@github.com:[yourgitname]/[yourgitname].github.io.githexo d #最后就可以deploy了</code></pre><h2 id="对于每次部署新博文到GitHub上时，重定向域名失效问题的解决方法"><a href="#对于每次部署新博文到GitHub上时，重定向域名失效问题的解决方法" class="headerlink" title="对于每次部署新博文到GitHub上时，重定向域名失效问题的解决方法"></a><font color="red"><strong>对于每次部署新博文到GitHub上时，重定向域名失效问题的解决方法</strong></font></h2><p>首先需要确定GitHub仓库根目录下已有CNAME文件，在本地博客根目录文件夹下<strong>source</strong> 文件夹里新建一个CNAME文件（<font color="red"><strong>注意该文件没有后缀名</strong></font>），内容为你的域名<code>flying2the.top</code>（<font color="red"><strong>这里不需要写www或者https</strong></font>），然后hexo g -d</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>R语言数据处理基础</title>
      <link href="/2022/05/11/r-yu-yan-shu-ju-chu-li-ji-chu/"/>
      <url>/2022/05/11/r-yu-yan-shu-ju-chu-li-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>在 R 中有许多用于数据框基本操作的内置函数，比如 transform()、rbind()、cbind()等函数，都是基于base 包的。base 包是安装 R 时会自带的包，无须加载包就可以直接使用。除此之外，还有如下 几种常用的数据处理的包。</p><p>（1）dplyr 包：dplyr 包是 Hadley Wickham（ggplot2 包的作者）的杰作，他将原本 plyr 包中的 ddply()等函数进一步分离强化， 专注接受 dataframe 对象，大幅提高了速度，并且提供了更稳健地与其他数据库对象间的接口。该包常用的函数包括：<strong>变量筛选函数 select()、记录筛选函数 filter()、排序函数 arrange()、变形（计算） 函数 mutate()、汇总函数 summarize()、分组函数 group_by()、随机抽样函数 sample_n()和 sample_frac()， 以及多步操作连接符 %&gt;%等。</strong></p><p>（2）tidyr 包：在具体应用中，tidyr 包经常与 dplyr 包共同使用，目前渐有取代 reshape2 包之势， 是值得关注的一个 R 包。在 tidyr 包中，有 4 个常用的函数，分别是：<strong>gather()函数用于将宽数据转换为长数据；spread()函数用于将长数据转换为宽数据；unite()函数用于将多列数据合并为一列数据； separate()函数用于将一列数分离为多列数。</strong></p><p>（3）reshape2 包：reshape2 包是由 Hadley Wickham 开发的<strong>用于数据重构的包</strong>，主要功能函数为 melt()、cast()，其实现了长数据和宽数据之间的转换，包中还包含 add_margin()等其他函数和 french_fries（三种不同的油对薯条口感的影响）等数据集。</p><p>（4）tidyverse 包：tidyverse 是由 Hadley Wickham 于 2017 年创建的 R 包的集合，它“分享整洁数据的基础设计理念、语法和数据结构”。核心软件包是 ggplot2、dplyr、tidyr、readr、purrr、tibble、 stringr 和 forcats，它们提供了建模、转换和可视化数据的功能。更多内容可以见他出版的新书 R for  Data Science。其中，readr 包用于读取数据，tidyr 包用于整理数据，dplyr 包用于数据转换，ggplot2 包用于数据可视化，purrr 包用于函数式编程。大家如对此有兴趣，可以更加深入地学习。</p><h2 id="这里简单介绍一下一维表和二维表的区别"><a href="#这里简单介绍一下一维表和二维表的区别" class="headerlink" title="这里简单介绍一下一维表和二维表的区别"></a>这里简单介绍一下一维表和二维表的区别</h2><p>一维数据列表就是由字段和记录组成的表格。一般来说字段在首行， 下面每一行是一条记录。一维数据列表通常可以作为数据分析的数据源， 每一行代表完整的一条数据记录，所以可以很方便地进行数据的录入、 更新、查询、匹配等。<strong>仅需通过单行就能确定数值的，被称为一维表。</strong></p><p><img src="https://pic1.zhimg.com/80/v2-066d0eb84c4abf113c6f32f6e960e55c_720w.jpg"></p><p>为了方便浏览打印美观，很多人会把重复姓名合并单元格，如下图（合并单元格只是格式美观，对数据清洗反而是一大障碍，会耗费额外时间精力）</p><p><img src="https://pic2.zhimg.com/80/v2-bb0b2f10101044f57348c7d6a4038af1_720w.png"></p><p>二维数据列表就是行和列都有字段，它们相交的位置是数值的表格。 这类表格一般是由分类汇总得来的，既有分类，又有汇总，所以是通过 一维数据列表加工处理过的，通常用于呈现展示。<strong>确定一个数值，必须通过行列两个条件去定位，这是二维表最显著的特征</strong>，如下图：</p><p><img src="https://pic1.zhimg.com/80/v2-4939d593f8d439fa57aee14ab2fd68e0_720w.jpg"></p><p>最早接触一维表的，是那些数据库从业者，因为一维表大都是系统自动生成的。但凡从数据库系统里导出来的表，不管是XLS还是CSV，都是一维表样式。<strong>换句话说，一维表是符合数据库设计规范的，需要行和列来定位数值的，就是二维表；仅靠单行就能锁定全部信息的，就是一维表</strong>，一维表、二维表可以相互转换。一维转二维用透视表，反之用逆透视。</p><h2 id="2-1表格的转换"><a href="#2-1表格的转换" class="headerlink" title="2.1表格的转换"></a>2.1表格的转换</h2><h3 id="2-1-1表格的变换"><a href="#2-1-1表格的变换" class="headerlink" title="2.1.1表格的变换"></a>2.1.1表格的变换</h3><p>在使用 R ggplot2 绘图时，通常使用一维数据列表的数据框。但是如果导入的数据表格是二维数据列表，我们则需要使用 reshape2 包的 melt()函数或者 tidyr 包的 gather()函数，可以<strong>将二维数据列表的数据框转换成一维数据列表，首先构造数据框：</strong></p><pre class=" language-R"><code class="language-R">df<- data.frame(x=c('A','B','C'),'2010'=c(1,3,4),'2011'=c(3,5,2),check.names=FALSE)</code></pre><p>（1）将宽数据转换为长数据，将多行聚集成列，从而将二维数据列表变成一维数据列表：</p><pre class=" language-R"><code class="language-R">df_melt<- reshape2::melt(df, id.vars="x",variable.name="year",value.name = "value")df_gather<- tidyr:: gather(df,year,value,-x#以上两句实现相同的效果</code></pre><p>其中，id.vars (“x”)表示由标识变量构成的向量，用于标识观测的变量；variable.name (“year”)表示用于保存原始变量名的变量的名称；value.name(“value”)表示用于保存原始值的名称。</p><p>（2）将长数据转换为宽数据，将一列根据变量展开为多行，从而将一维数据列表变成二维数据列表：</p><pre class=" language-R"><code class="language-R">df_dcast<- reshape2:: dcast (df_melt,x~year,value.var="value")df_spread <- tidyr::spread(df_gather,year, value)#以上两句实现相同的效果</code></pre><p>其中，dcast 借助于公式来描述数据的形状 id.vars~variable.name，左边参数表示 id.vars (“x”)， 而右边的参数表示 variable.name (“year”)。</p><p><font color="purple">&nbsp;<strong>此处插入图片</strong></font></p><h3 id="2-1-2变量的变换"><a href="#2-1-2变量的变换" class="headerlink" title="2.1.2变量的变换"></a>2.1.2变量的变换</h3><p>有时候，需要对数据框中某列的每个元素都进行运算处理，从而产生并添加新的列。可以使用 R 内置函数 transform()为原数据框添加新的列，可以改变原变量列的值， 也可以赋值 NULL 删除列变量：</p><pre class=" language-R"><code class="language-R">dat1<-transform(df_melt, value2=value*2)</code></pre><p>可以结合向量化的条件语句 ifelse()进行复杂运算。另外，dplyr 包的 mutate()函数也能实现与 transform()函数相同的功能。但是 mutate()函数很好地解决了 transform()函数不能解决的 问题，即 mutate()函数允许新列对刚刚建立起来的列进行计算。</p><pre class=" language-R"><code class="language-R">dat2<- transform(df_melt, value2=ifelse(year=="2011", value*2, value))dat2<- dplyr:: mutate(df_melt, value2=ifelse(year=="2011", value*2, value)#将2011年的数据翻倍</code></pre><p><font color="purple"> <strong>此处插入图片</strong></font></p><h3 id="2-1-3表格的排序"><a href="#2-1-3表格的排序" class="headerlink" title="2.1.3表格的排序"></a>2.1.3表格的排序</h3><p>此外可以使用 sort()函数对向量进行排序处理。对于数据框，我们可使用 dplyr 包的 arrange()函数，根据数据框的某列数值对整个表排序。其中 desc(value)表示根据 df 的 value 列做降序处理，如 dat_arrange2 数据框所示。</p><pre class=" language-R"><code class="language-R">dat_arrange1<- dplyr:: arrange (df_melt, value)dat_arrange2<- dplyr:: arrange (df_melt, desc(value))</code></pre><p><font color="purple"> <strong>此处插入图片</strong></font></p><h2 id="2-2表格的整理"><a href="#2-2表格的整理" class="headerlink" title="2.2表格的整理"></a>2.2表格的整理</h2><h3 id="2-2-1表格的拼接"><a href="#2-2-1表格的拼接" class="headerlink" title="2.2.1表格的拼接"></a>2.2.1表格的拼接</h3><p>需要在已有数据框的基础上添加新的行/列，或者横向/纵向添加另外一个表格。此时需要使用R内置函数 cbind()和 rbind()，或者 dplyr 包的 bind_cols()函数和 bind_rows()函数实现该功能。先构造 3 个数据框如下：</p><pre class=" language-R"><code class="language-R">df1<-data.frame(x= c("a","b","c"), y=1:3)df2<- data.frame(z= c("B","D","H"), g =c(2,5,3))df3<- data.frame(x= c("g","d"), y =c(2,5))</code></pre><p>（1）数据框添加列或者横向添加表格：</p><pre class=" language-R"><code class="language-R">dat_cbind<-cbind(df1,df2) </code></pre><p>（2）数据框添加行或者纵向添加表格：</p><pre class=" language-R"><code class="language-R">dat_rbind<-rbind(df1,df3)</code></pre><p><font color="purple"> <strong>此处插入图片</strong></font></p><h3 id="2-2-2表格的融合"><a href="#2-2-2表格的融合" class="headerlink" title="2.2.2表格的融合"></a>2.2.2表格的融合</h3><p>有时，两个数据框并没有很好地保持一致，不能简单地使用 cbind()函数或 rbind()函数直接拼接。所以它们<strong>需要一个共同的列（common key）作为融合的依据。</strong>在表格的融合中，最常用的函数是R内置函数 merge()和 dplyr 包的*_join()系列函数。我们首先构造 4 个数据框，如下：</p><pre class=" language-R"><code class="language-R">df1<-data.frame(x= c("a","b","c"), y=1:3)df2<- data.frame(x= c("a","b","d"), z =c(2,5,3))df3<- data.frame(g= c("a","b","d"), z =c(2,5,3))df4<- data.frame(x= c("a","b","d"), y=c(1,4,2),z =c(2,5,3))</code></pre><p><font color="purple"> <strong>此处插入图片</strong></font></p><p>（1）merge()函数</p><p>其优势在于对每个数据框可以指定不同的匹配列名；缺点在于运行速度比较慢。其中，by.x 是指左边数据框的匹配列，by.y 是指右边数据框的匹配列。</p><pre class=" language-R"><code class="language-R">dat_merge1 <-merge(df1,df2,by="x", all = TRUE) dat_merge2 <-merge(df1,df3,by.x="x",by.y="g") dat_merge3 <-merge(df1,df4,by=c("x","y"), all = TRUE) </code></pre><p>效果如下所示</p><p><font color="purple"> <strong>此处插入图片</strong></font></p><p>（2）*_join()系列函数</p><p>dplyr 包提供了 left_join()、 right_join()、inner_join()和 full_ join()四个函数，可以实现不同的表格融合效果。其中，full_ join()函数主要用来生成两个集合的并集；inner_join()函数通常用来生成有效的数据；left_join()函数和 right_join()函数使用的场景偏少。另外，两个表格融合时会用 NA（缺失 值）代替不存在的值。</p><ul><li>只保留左表的所有数据：</li></ul><pre class=" language-R"><code class="language-R">dat_join1 <-dplyr::left_join (x=df1,y=df2,by="x")</code></pre><ul><li>只保留右表的所有数据：</li></ul><pre class=" language-R"><code class="language-R">dat_join2 <-dplyr::right_join (x=df1,y=df2,by= "x")</code></pre><ul><li>只保留两个表中公共部分的信息：</li></ul><pre class=" language-R"><code class="language-R">dat_join3 <-dplyr::inner_join (x=df1,y=df2,by="x")</code></pre><ul><li>保留两个表的所有信息：</li></ul><pre class=" language-R"><code class="language-R">dat_join4 <-dplyr:: full_join(x=df1,y=df2,by="x")</code></pre><p><font color="purple"> <strong>此处插入图片</strong></font></p><ul><li>by=c(“x”,”y”)表示多列匹配：</li></ul><pre class=" language-R"><code class="language-R">dat_join5 <-dplyr::left_join (x=df1,y=df4,by= c("x","y"))</code></pre><ul><li>by=c(“x”=”g”)可以根据两个表的不同列名合并：</li></ul><pre class=" language-R"><code class="language-R">dat_join6 <-dplyr::left_join (x=df1,y=df3,by= c("x"="g"))</code></pre><ul><li>如果与表合并的过程中遇到有一列在两个表中同名，但是值不同，合并的时候又都想保留下来，就可以用 suffix 给每个表的重复列名增加后缀：</li></ul><pre class=" language-R"><code class="language-R">dat_join7<-dplyr::left_join (x=df1,y=df4,by="x", suffix=c(".1",".2"))</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>R语言实战</title>
      <link href="/2022/05/11/r-yu-yan-shi-zhan/"/>
      <url>/2022/05/11/r-yu-yan-shi-zhan/</url>
      
        <content type="html"><![CDATA[<h2 id="一、R语言编程与绘图基础"><a href="#一、R语言编程与绘图基础" class="headerlink" title="一、R语言编程与绘图基础"></a>一、R语言编程与绘图基础</h2><h3 id="1、R语言编程基础"><a href="#1、R语言编程基础" class="headerlink" title="1、R语言编程基础"></a>1、R语言编程基础</h3><h4 id="1-1数据类型"><a href="#1-1数据类型" class="headerlink" title="1.1数据类型"></a>1.1数据类型</h4><p>R中常见的数据类型为数值型（numeric）、字符型（character）、日期型（date）、逻辑型（logical），变量的数据类型都可以用class()函数查看</p><ul><li><p>数值型</p><pre class=" language-R"><code class="language-R">a<- 1;is.numeric(a)#输出判定a是否为数值型：TRUE</code></pre></li><li><p>字符型</p><pre class=" language-R"><code class="language-R">b<- "peter"; nchar(b)#输出字符串的长度</code></pre></li><li><p>日期型</p><p>最常用的日期型数据类型是Date（进存储日期）和POSIXct（同时存储日期和时间）</p><pre class=" language-R"><code class="language-R">c<-as.Date("2012-06-12");class(c)#输出c的类型为Dated<-as.POSIXct（"2012-06-12 17:32"）; class(d) #输出 d 的数据类型为："POSIXct" "POSIXt"</code></pre></li><li><p>逻辑型</p><pre class=" language-R"><code class="language-R">e<-TRUE, f<-FALSE</code></pre><p>其中，在处理时序数据时，我们需要处理日期型数据，往往需要使用 as.Date()函数将读入的数据从数值型转换成日期型，有时候还需要进一步提取日期型数据的年、月、周等数据信息。此时我 们需要使用 as.numeric()函数或者 as.integer()函数将日期型数据转换成数值型。其中，strftime(x, format  = “”)函数可以定义日期型数据的格式，比如 strftime(c, ‘%Y’)表示只显示年份。</p><pre class=" language-R"><code class="language-R">c_Year<- as.integer(strftime(c, '%Y')) #输出年份：2012 c_month <- as.integer(strftime(c, '%m')) #输出月份：6 c_week<- as.integer(strftime(c, '%W')) #输出周数：24</code></pre></li></ul><h4 id="1-2数据结构"><a href="#1-2数据结构" class="headerlink" title="1.2数据结构"></a>1.2数据结构</h4><p>常见的数据结构包括：<strong>向量（vector）</strong>、<strong>数据框（data.frame）</strong>、<strong>矩阵（matrix）</strong>、<strong>列表（list）</strong>和<strong>数组（array）</strong>。其中，矩阵是将数据用行和列排列的长方形表格，<strong>矩阵是二维数组，<em>其单元必须是相同的数据类型</em></strong>，通常用列来表示不同的变量，用行表示各个对象；<strong>数组可以看作是带有多个下标的类型 相同的元素的集合</strong>；列表是一个对象的有序集合构成的对象，列表中包含的对象又称为它的分量 （component），分量可以是不同的模式或（和）类型。我们在本书的<strong>数据可视化中，比较常用的是向量（因子属于特殊的向量）和数据框</strong>，所以我们重点介绍这两种类型的数据结构，还将介绍与数据可视化密切相关的函数。</p><h5 id="1-2-1向量"><a href="#1-2-1向量" class="headerlink" title="1.2.1向量"></a>1.2.1向量</h5><p>向量是用于存储数值型、字符型或逻辑型数据的一维数组。执行组合功能的函数 c()可用来创建 向量（c 代表合并：combine）。值得注意的是，<strong>单个向量中的数据类型是固定的</strong>，比如数值型向量中的元素就必须全为向量。向量是 R 语言中最基本的数据结构, 其他类型的数据结构都可以由向量构 成。最常见的向量有三种类型：数值型、字符型、逻辑型。</p><p><strong>（1）向量的创建</strong></p><p>向量的创建有多种方法，我们既可以手动输入，使用函数 c()创建向量；也可以使用现有的函数 创建向量，比如 seq()、rep()等函数</p><table><thead><tr><th align="center">输入</th><th align="center">输出</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">c(2,4,6)</td><td align="center">2 4 6</td><td align="center">将元素连接成向量</td></tr><tr><td align="center">2:6</td><td align="center">2 3 4 5 6</td><td align="center">等差整数数列</td></tr><tr><td align="center">seq(2, 3, by=0.5)</td><td align="center">2.0 2.5 3.0</td><td align="center">步长为 0.5 的等差数列</td></tr><tr><td align="center">rep(1:2, times=3)</td><td align="center">1 2 1 2 1 2</td><td align="center">将一个向量重复 3 次</td></tr><tr><td align="center">rep(1:2, each=3)</td><td align="center">1 1 1 2 2 2</td><td align="center">将一个向量中的每个元素重复 3 次</td></tr><tr><td align="center">rnorm(3, mean = 0, sd = 3)</td><td align="center">0.3823209 1.3203584 3.1263230</td><td align="center">均值为 0、标准差为 3 的正态分布</td></tr><tr><td align="center">runif(3, min = 0, max = 1)</td><td align="center">0.9552905 0.6813195 0.4527798</td><td align="center">最大值为 1、最小值为 0 的均匀分布</td></tr><tr><td align="center">sample(c(“A”,”B”,”C”), 4, replace=TRUE)</td><td align="center">“A” “A” “A” “B”</td><td align="center">从一个向量中随机抽取</td></tr></tbody></table><p><strong>（2）向量的处理</strong></p><ul><li><p>向量的排序</p><p>很多时候我们需要先对数据进行降序处理，再展示数据 。 sort() 函数可以实现对向量的排序处理，index.return=TRUE，表示返回排序的索引；decreasing = TRUE，表示降序处理。</p><pre class=" language-R"><code class="language-R">Vec<-c(1,4,3,5,2)order<-sort(Vec, index.return=TRUE,decreasing = TRUE)输出结果为：$x 为[5 4 3 2 1]，$ix 为[4 2 3 5 1]</code></pre></li><li><p>向量的唯一值</p><p>unique()函数主要是返回一个删除了重复元素或行的向量、数据框或数组。在需要对数据框根据某列进行分组运算时，需要使用该函数先获取类别总数。</p><pre class=" language-R"><code class="language-R">Vec<-c("peter","jack","peter","jack","eelin")Uni<-unique(Vec) #输出："peter", "jack", "eelin"</code></pre></li><li><p>连续向量的离散化</p><p>有时需要把连续型变量转换为离散型变量， 这种转换的过程就是<strong>数据离散化</strong>，<strong>分箱</strong>就是离散化常用的一种方法。数据离散化最简单的方法就是使用 cut()函数自定义离散区间，从而对数据进行离散处理。</p><pre class=" language-R"><code class="language-R">Num_Vector<- c(10, 5, 4, 7, 6, 1, 4, 8, 8, 5)Cut_Vector<-cut(Num_Vector,breaks=c(0,3,6,9,11), labels=c("0~3", "3~6", "6~9", ">9"), right = TRUE)#输出结果为因子向量：>9, 3~6, 3~6, 6~9, 3~6, 0~3, 3~6, 6~9, 6~9, 3~6；其水平 Levels 为: 0~3, 3~6, 6~9, >9</code></pre></li></ul><p><strong>（3）向量的索引</strong></p><p>向量是多个元素的集合，当我们只需要指定或者说提取该向量中的某个元素时，就可以使用向量的索引（indexing）。向量元素有三种基本类型的向量索引：<strong>整数型</strong>，索引的是元素位置；<strong>字符型</strong>， 索引的是名称属性；<strong>逻辑型</strong>，索引的是相同长度的逻辑向量对应的逻辑值为真的元素。</p><pre class=" language-R"><code class="language-R">x<-c(1,4,3,5,2)</code></pre><ul><li>整数型索引，选择某个或多个元素：x[2]; x[-2]; x[2:4]; x[c(1,4)]</li><li>逻辑型索引，逻辑运算选择元素：x[x&gt;2]; x[x==1]; x[x&lt;=5]</li></ul><h6 id="1-2-2因子"><a href="#1-2-2因子" class="headerlink" title="1.2.2因子"></a>1.2.2因子</h6><p>因子（factor）是 R 语言中许多强大运算的基础，包括许多针对表格数据的运算，可分为类别型变量和有序型变量。因子可以看成是<strong>包含了额外信息的向量</strong>，这额外的信息就是不同的类别，称之为水平（level）。因子在 R 中非常重要，因为它决定了数据的分析方式，以及如何进行视觉呈现。</p><p><strong>（1）因子的创建</strong></p><p>一个因子不仅包括分类变量本身，还包括变量不同的可能水平（即使它们在数据中不出现）。因 子函数 factor()用下面的选项创建一个因子。对于字符型向量，因子的水平默认依字母顺序创建:</p><pre class=" language-R"><code class="language-R">(Fair,Good, Ideal, Premium, Very Good)Cut<-c("Fair","Good","Very Good","Premium","Ideal") Cut_Facor1<-as.factor(Cut)#以下为输出结果#[1] Fair      Good      Very Good Premium   Ideal    #Levels: Fair Good Ideal Premium Very Good</code></pre><p><strong>（2）水平的更改</strong></p><p>可以指定 levels 选项来覆盖默认排序（按默认是以字母顺序排序）。更改因子向量的 levels 为(“Good”,”Fair”,”Very Good”,”Ideal”,”Premium”)，就需要使用 factor()函数更改 levels。</p><pre class=" language-R"><code class="language-R">Cut_Facor2<-factor(x=c("Fair","Good","Very Good","Premium","Ideal"), levels= c("Good","Fair","Very Good","Ideal","Premium"),  ordered=TRUE)#以下为输出结果#[1] Fair      Good      Very Good Premium   Ideal    #Levels: Good < Fair < Very Good < Ideal < Premium</code></pre><p><strong>（3）类型的转换</strong></p><p>数值型因子向量的类型变换。有时候需将数值型的因子向量重新转换成数值型向量，这时，需要使用 as.numeric(as.character())组合函数，而不能直接使用 as.numeric()函数。其中 as.character() 函数表示将向量变成字符型，as.numeric()函数表示将向量变成数值型。</p><pre class=" language-R"><code class="language-R">Num _Facor<-factor(x=c(1,3,5,2), levels= c(5,3,2,1), ordered=TRUE) Num_Vector1<-as.numeric(as.character(Num_Facor)) # 输出：1 3 5 2Num_Vector2<-as.numeric(Num_Facor) # 输出：4 2 1 3</code></pre><h5 id="1-2-3数据框"><a href="#1-2-3数据框" class="headerlink" title="1.2.3数据框"></a>1.2.3数据框</h5><p>数据框是 R 语言中的一种表格结构，数据框是由多个向量构成的，每个向量的长度相同。数据框类似矩阵，也是一个二维表结构。在统计学术语中，用行来表示观测（observation），用列来表示变量（variable）。</p><p><strong>（1）数据框的创建与查看</strong></p><p>创建数据框，最简单的方法就是，用同名的定义函数 data.frame()，输入每个变量的名称及对应的向量，每个向量的长度相同。一个数据框可能包含多个变量（向量），有时需要单独提取某个变量， 使用特殊的$符号来访问，由“数据框$变量名”构成。</p><ul><li>获取数据框的行数、列数和维数：nrow()、ncol()、dim()。</li><li>获取数据框的列名或行名：names()、rownames()、colnames()；重新定义列名：names(df)&lt;-c(“X”,  “Y”, “Z”)。</li><li>观察数据框的内容：view(df)、head(df, n=3)、tail(df)。</li></ul><p><strong>（2）空数据框的创建</strong></p><p>创建空数据框，在需要自己构造绘图的数据框数据信息时尤为重要。有时，在绘制复杂的数据图表的过程中，我们需要对现有数据进行插值、拟合等处理，这时需要使用空的数据框存储新的数据，最后使用新的数据框绘制图表。创建空的数据框主要有如下两种方法。</p><ul><li>创建一个名为 Df_Empty，包括两个变量（var_a 为 numeric 类型；var_b 为 character 类型）的 data.frame。但是注意：要加上 stringsAsFactors=FALSE，否则在后面逐行输入数据时，会因 为 var_b 的取值未经定义的 factor level 而报错。</li></ul><pre class=" language-R"><code class="language-R">Df_Empty1<- data.frame(var_a = numeric(),var_b = character(),stringsAsFactors=FALSE)</code></pre><ul><li><p>先使用矩阵创建空的数据框，同时通过 dimnames 设定数据框的列名。这个相比前一种方法 可以更快速地创建多列空数据框：</p><pre class=" language-R"><code class="language-R">Df_Empty2 <- data.frame(matrix(ncol=2, nrow=0,dimnames=list(c(),c("var_a","var_b"))))</code></pre></li></ul><h4 id="1-3数据属性"><a href="#1-3数据属性" class="headerlink" title="1.3数据属性"></a>1.3数据属性</h4><p>数据框作为 R 语言数据分析与可视化很常用的数据结构，常由多列不同数据属性的变量组成。 在我们实现数据可视化时，很有必要先了解这些变量的属性。Jiawei Han 等人的 Data mining: concepts and techniques根据数据属性取值的集合类型，将数据属性分成了三类：类别型、序数型和数值型。</p><h5 id="1-3-1类别型"><a href="#1-3-1类别型" class="headerlink" title="1.3.1类别型"></a>1.3.1类别型</h5><p>类别型属性（categorical attribute）是用于区分不同数据对象的符号或名称，而它们是没有顺序关系的，又包含多元类别和二元类别两种类型。对于多元类别，可以理解为购买服装时的不同服装名称，如衬衫、毛衣、T 恤、夹克等；对于二元类别，可以理解为购买服装时的不同性别，只有男士和女士两种性别分类。</p><h4 id="1-4数据的导入与输出"><a href="#1-4数据的导入与输出" class="headerlink" title="1.4数据的导入与输出"></a>1.4数据的导入与输出</h4><h4 id="1-5控制语句与函数编写"><a href="#1-5控制语句与函数编写" class="headerlink" title="1.5控制语句与函数编写"></a>1.5控制语句与函数编写</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/04/hello-world/"/>
      <url>/2022/05/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
