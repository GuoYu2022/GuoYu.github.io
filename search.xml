<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>最近一些新的问题</title>
      <link href="/2022/05/31/zui-jin-yi-xie-xin-de-wen-ti/"/>
      <url>/2022/05/31/zui-jin-yi-xie-xin-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="关于ssh-connect-to-host-github-com-port-22-Connection-refused问题的解决方法"><a href="#关于ssh-connect-to-host-github-com-port-22-Connection-refused问题的解决方法" class="headerlink" title="关于ssh: connect to host github.com port 22: Connection refused问题的解决方法"></a>关于ssh: connect to host github.com port 22: Connection refused问题的解决方法</h1><p>最近在本地写完博客md文件后准备deploy到GitHub服务器上时，报了一个22端口拒绝连接的错误</p><p>于是，测试一下SSH连接状况</p><pre class="line-numbers language-shell"><code class="language-shell">$ ssh -T git@github.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果还是报了ssh: connect to host github.com port 22: Connection refused</p><h2 id="第一种解决方法——使用443端口"><a href="#第一种解决方法——使用443端口" class="headerlink" title="第一种解决方法——使用443端口"></a>第一种解决方法——使用443端口</h2><p>即在用户目录文件夹下的.ssh文件中生成一个config文件</p><pre class="line-numbers language-shell"><code class="language-shell">cd C:/Users/yuguo/.sshnano config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在config文件里指明使用443端口</p><pre class="line-numbers language-shell"><code class="language-shell">Host github.com  User github注册邮箱地址  Hostname ssh.github.com  PreferredAuthentications publickey  IdentityFile ~/.ssh/id_rsa  Port 443<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果提示443端口报错，ssh: connect to host ssh.github.com port 443: Connection refused，此路不通。</p><h2 id="第二种解决方法——使用SSH协议"><a href="#第二种解决方法——使用SSH协议" class="headerlink" title="第二种解决方法——使用SSH协议"></a>第二种解决方法——使用SSH协议</h2><p>第一步，查看当前git的远程仓库版本</p><pre class="line-numbers language-shell"><code class="language-shell">git remote -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里报了一个没有找到.git文件的错误，fatal: not a git repository (or any of the parent directories): .git</p><p>那么就先初始化一下：</p><pre class="line-numbers language-shell"><code class="language-shell">git init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再来查看远程仓库版本</p><pre class="line-numbers language-shell"><code class="language-shell">git remote -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回结果为空，说明没有远程仓库。</p><p>第二步，添加ssh协议的远程仓库</p><pre class="line-numbers language-shell"><code class="language-shell">git remote add origin git@github.com:GuoYu2022/GuoYu2022.github.io.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>每个用户的远程仓库地址是不一样的，如何寻找自己的呢？</p><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E6%B5%8B%E8%AF%951.png"></p><p>在自己repo的右侧code控件处，有远程仓库的SSH协议的地址，复制它！</p><p>再次查看：</p><pre class="line-numbers language-shell"><code class="language-shell">$ git remote -vorigin  git@github.com:GuoYu2022/GuoYu2022.github.io.git (fetch)origin  git@github.com:GuoYu2022/GuoYu2022.github.io.git (push)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>已经传回远程仓库SSH地址了，再来测试一下SSH连接状况：</p><pre class="line-numbers language-shell"><code class="language-shell">$ ssh -T git@github.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>仍然报443端口错误，此路不通。ssh: connect to host ssh.github.com port 443: Connection refused</p><h2 id="第三种解决方法——使用HTTPS协议"><a href="#第三种解决方法——使用HTTPS协议" class="headerlink" title="第三种解决方法——使用HTTPS协议"></a>第三种解决方法——使用HTTPS协议</h2><p>第一步，先移除掉远程仓库的配置</p><pre class="line-numbers language-shell"><code class="language-shell">$ git remote rm origin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第二步，重新添加远程仓库的HTTPS地址</p><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E6%B5%8B%E8%AF%952.png"></p><pre class="line-numbers language-shell"><code class="language-shell">$ git remote add origin https://github.com/GuoYu2022/GuoYu2022.github.io.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再次查看：</p><pre class="line-numbers language-shell"><code class="language-shell">$ git remote -vorigin  https://github.com/GuoYu2022/GuoYu2022.github.io.git (fetch)origin  https://github.com/GuoYu2022/GuoYu2022.github.io.git (push)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>证明已切换至Https协议了，再来测试一下SSH连接状况：</p><pre class="line-numbers language-shell"><code class="language-shell">$ ssh -T git@github.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>仍然443端口报错，ssh: connect to host ssh.github.com port 443: Connection refused，此路不通！！！</p><h2 id="第四种解决方法——修改hosts文件"><a href="#第四种解决方法——修改hosts文件" class="headerlink" title="第四种解决方法——修改hosts文件"></a>第四种解决方法——修改hosts文件</h2><p>最近突然看到了这篇文章：<a href="https://segmentfault.com/a/1190000041909858">坑：ssh: connect to host github.com port 22: Connection refused - SegmentFault 思否</a></p><p>因为这文章是最新的文章，问题也是一样，来看看那位作者是怎么解决这个问题：</p><p>带上-v参数，打印ssh -T的详细日志</p><pre class="line-numbers language-shell"><code class="language-shell">$ ssh -vT git@github.comOpenSSH_8.9p1, OpenSSL 1.1.1n  15 Mar 2022debug1: Reading configuration data /c/Users/yuguo/.ssh/configdebug1: /c/Users/www/.ssh/config line 1: Applying options for github.comdebug1: Reading configuration data /etc/ssh/ssh_configdebug1: Connecting to ssh.github.com [::1] port 443.debug1: connect to address ::1 port 443: Connection refuseddebug1: Connecting to ssh.github.com [127.0.0.1] port 443.debug1: connect to address 127.0.0.1 port 443: Connection refusedssh: connect to host ssh.github.com port 443: Connection refused<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的信息马上就发现了诡异的地方，连接github.com的地址居然是<code>::1</code>和<code>127.0.0.1</code>。前者是IPV6的localhost地址，后者是IPV4的localhost地址。</p><p>到这里问题就很明确了，是DNS解析出问题了，导致github.com域名被解析成了localhost的ip地址，就自然连不上GitHub了。</p><p>Windows下执行<code>ipconfig /flushdns</code> 清楚DNS缓存后也没用，最后修改hosts文件，增加一条github.com的域名映射搞定。</p><pre class="line-numbers language-bash"><code class="language-bash">140.82.113.4 github.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如何修改hosts文件呢？进入C:\WINDOWS\system32\drivers\etc路径。</p><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E6%B5%8B%E8%AF%953.png"></p><p>点击右上角文件，以管理员身份运行powershell，输入notepad hosts，就可以编辑hosts文件了</p><p>使用谷歌的dns服务器查看github.com的解析地址</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">nslookup</span> github.com 8.8.8.8Non-authoritative answer:Server:  dns.googleAddress:  8.8.8.8Name:    github.comAddress:  20.205.243.166<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<a href="https://www.ipaddress.com/">IPAddress</a>查询20.205.243.166，显示该地址的ISP是位于新加坡的微软公司（GitHub已被微软收购），说明使用谷歌dns来解析GitHub地址是正常的。</p><p>接着使用本地已修改后的hosts文件直接解析GitHub地址</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">nslookup</span> github.comServer:  UnKnownAddress:  192.168.8.1Name:    github.comAddresses:  ::1          127.0.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>没有解析出来，有种不良的预感。</p><p>再来测试一下SSH连接状况：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ssh</span> -T git@github.comssh: connect to host ssh.github.com port 443: Connection refused<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>果然还是GG了。。。</p><p>尽管失败了，但是作者归咎的原因有两点：</p><p>这个问题其实就是DNS解析被污染了，有2种可能：</p><ul><li>DNS解析被运营商劫持了</li><li>使用了科学上网工具</li></ul><h2 id="第五种解决方法——直接指定DNS服务器"><a href="#第五种解决方法——直接指定DNS服务器" class="headerlink" title="第五种解决方法——直接指定DNS服务器"></a>第五种解决方法——直接指定DNS服务器</h2><p>因为第四种方法作者直接指出了是DNS解析被污染了，那我们就顺着这个思路，因为简体中文win10默认设置是从ISP那里自从获取ipv4地址和dns服务器地址，那么我们干脆直接指定DNS服务器地址，直接把问题解决到根子上去。</p><p>通过控制面板——网络和Internet——网络和共享中心</p><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E6%B5%8B%E8%AF%954.png"></p><p>点击以太网，然后点击属性</p><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E6%B5%8B%E8%AF%955.png"></p><p><strong>双击ipv4协议</strong></p><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E6%B5%8B%E8%AF%956.png"></p><p>设置首选的dns服务器为腾讯的119.29.29.29，备选dns服务器为谷歌的8.8.8.8</p><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E6%B5%8B%E8%AF%957.png"></p><p>再来测试一下SSH连接状况：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ssh</span> -T git@github.comThe authenticity of host <span class="token string">'[ssh.github.com]:443 ([20.205.243.160]:443)'</span> can<span class="token string">'t be established.ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU.This host key is known by the following other names/addresses:    ~/.ssh/known_hosts:1: github.comAre you sure you want to continue connecting (yes/no/[fingerprint])? yesWarning: Permanently added '</span><span class="token punctuation">[</span>ssh.github.com<span class="token punctuation">]</span>:443<span class="token string">' (ED25519) to the list of known hosts.Hi GuoYu2022! You'</span>ve successfully authenticated, but GitHub does not provide shell access.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><font color="red">成功了！！！</font></strong></p><h2 id="不能算是跋的跋"><a href="#不能算是跋的跋" class="headerlink" title="不能算是跋的跋"></a>不能算是跋的跋</h2><p>能看到这的朋友可以当个乐子看看我后面随便写写的话，或者直接可以关闭页面了，这一块简单聊聊我近期的想法，因为主要要写的东西已经结束了。</p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%B7%B2%E7%BB%8F%E7%BB%93%E6%9D%9F%E5%95%A6.jpg" alt="已经结束啦" style="zoom: 33%;"><p>前段时间，写的第二篇文章<a href="https://flying2the.top/2022/05/11/da-jian-bo-ke-za-tan/">搭建博客杂谈 | 余果的博客 (flying2the.top)</a>没有提到我现在写博客所使用的工具栈，所以简单聊聊我的博客工具栈，typora的最后一个beta版本（不想用破解版又不想花钱的，可以考虑beta）+picgo（typora官方钦点的图床管理工具，配合typora使用感真的是丝滑）+图床使用的是GitHub图床（不想花钱买服务器，GitHub上新建一个repo就可以了，前提你要会爬墙，不然国内直连GitHub的网速可是感人的）。</p><p>而今年看了不少文章，都提到了gitee图床莫名其妙就崩了事情，主要是gitee觉得自己是个商业公司，又不像GitHub有微软那样的金主爸爸，薅羊毛居然薅到自己头上了，有点难以接受，甚至不少博主放在gitee上的支付宝、微信的收款码、赞赏码直接就被锁住或者失效了。加上gitee最近闹出的加强code censorship的事情，回想当时挑选工作栈时慎之又慎，没有选择gitee，现在看来还是蛮准确的。所以回到最初想说的，当我的小小博客站依托于GitHub pages和GitHub图床（GitHub给了每个仓库1G的上限，但我想纯纯放图应该是绰绰有余了，如果不够了就新开repo呗），如果你打开我的博客网页一直在转圈圈或者所有图你看到似乎都挂掉了，那有可能是你打开的方式不对，因为我本人是没有考虑做国内cdn服务器加速的，因为那又是一笔钱，能省则省吧。至于后面的话，就是搞我的R4DS的读书笔记，以及顺便继续搞我的博客站优化，其实博客还没有弄完，但是急着想写点东西或者做记录，所以就勉强拿个半成品博客站在耍了。最后，感谢你看到最后，如果你觉得我的文章写的还可以，能赞赏我一杯咖啡就更好了。</p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%BE%88%E9%9A%BE%E7%9A%84%E5%95%A6.png" style="zoom:33%;">]]></content>
      
      
      <categories>
          
          <category> 解决问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
            <tag> 问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R4DS读书笔记（第三章、使用dplyr进行数据转换）</title>
      <link href="/2022/05/19/r4ds-du-shu-bi-ji-di-san-zhang-shi-yong-dplyr-jin-xing-shu-ju-zhuan-huan/"/>
      <url>/2022/05/19/r4ds-du-shu-bi-ji-di-san-zhang-shi-yong-dplyr-jin-xing-shu-ju-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>很多时候，数据集的数据格式并不符合我们的要求，有时需要创建新变量或者摘要统计量，此外还可能需要对变量进行重命名或者对观测值进行重排序，以便数据后期处理。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>这一部分重点介绍使用tidyverse中的另一个包：dplyr包，使用 nycflights13 包中的数据并借助ggplot2可视化来介绍dplyr包的用途。</p><pre class="line-numbers language-R"><code class="language-R">library(nycflights13)library(tidyverse) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>加载 tidyverse 时，注意输出的冲突信息，它会告诉你 dplyr 覆盖了基础 R 包中的哪些函数。如果想要在加载 dplyr 后使用这些函数的基础版本，那么需要使用完整名称：stats::filter() 和 stats::lag()。</p><h3 id="这里安装nycflights13包时出了问题"><a href="#这里安装nycflights13包时出了问题" class="headerlink" title="这里安装nycflights13包时出了问题"></a><font color="red">这里安装nycflights13包时出了问题</font></h3><p>起初解决这个问题的思路是设置Rstudio走代理，结果不行</p><p>然后设置Rstudio的包下载为国内镜像站，结果还是不行</p><p>于是大怒，直接谷歌到该包在CRAN上的具体下载地址，直接强制下载安装这个R包，这个方法比较暴力而且彻底，但是之后使用下载到本地的nycflights13 包时需要注明’nycflights13::’</p><pre class="line-numbers language-R"><code class="language-R">ggpack<-"https://cran.r-project.org/src/contrib/nycflights13_1.0.2.tar.gz"install.packages(ggpack, repos=NULL, type="source")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="nycflights13"><a href="#nycflights13" class="headerlink" title="nycflights13"></a>nycflights13</h3><p>使用 nycflights13::flights查询2013 年从纽约市出发的所有 336 776 次航班的信息</p><p>这个数据框的输出和我们以前用过的其他数据框有一点差别：只显示了前几行和适合屏幕宽度的几列。（要想看到整个数据集，可以使用 View(nycflights13::flights) 在 RStudio 查看器中打开数据集。）输出有差别是因为 flights 是一个 tibble。tibble 也是一种数据框， 只是进行了一些小小的修改，使其更适合在 tidyverse 中使用。</p><p>对于一些常用的变量类型：</p><ul><li>int表示整型变量</li><li>dbl表示双精度变量或实数</li><li>chr表示字符向量或字符串</li><li>dttm表示日期时间型变量</li><li>lgl表示逻辑型变量</li><li>fctr表示因子</li><li>date表示日期型变量</li></ul><h3 id="dplyr基础"><a href="#dplyr基础" class="headerlink" title="dplyr基础"></a>dplyr基础</h3><p>本章要学习dplyr的五个核心函数，可以解决数据处理中的绝大多数问题</p><ul><li>按值筛选观测（filter()）</li><li>对行进行重新排序（arrange()）</li><li>按名称选取变量（select()）</li><li>使用现有变量的函数创建新变量（mutate()）</li><li>将多个值总结为一个摘要统计量（summarize()）</li></ul><p>这些函数都可以和 group_by() 函数联合起来使用，group_by() 函数可以改变以上每个函数的作用范围，让其从在整个数据集上操作变为在每个分组上分别操作。</p><h3 id="使用filter-筛选行"><a href="#使用filter-筛选行" class="headerlink" title="使用filter()筛选行"></a>使用filter()筛选行</h3><p>filter() 函数可以基于观测的值筛选出一个观测子集。第一个参数是数据框名称，第二个参数以及随后的参数是用来筛选数据框的表达式。例如：</p><pre class="line-numbers language-R"><code class="language-R">dplyr::filter(nycflights13::flights,month==1,day==1)#筛选出1月1日的所有航班<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong><font color="red">注意这里要注明函数的包名出处，因为不同的包名包含相同名字的filter函数，因为是手动安装这个数据集包的，所以要带上nycflights13的名称</font></strong></p><p>执行上一句代码，dplyr 就会进行筛选操作，并返回一个新数据框。如需保存，则需赋值给一个对象。</p><pre class="line-numbers language-R"><code class="language-R">jan1 <- filter(flights, month == 1, day == 1)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><font color="red"><strong>如果想同时完成打印结果和赋值操作</strong></font></p><pre class="line-numbers language-R"><code class="language-R">(dec25 <- filter(flights, month == 12, day == 25))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>R 提供了一套标准的 比较运算符：&gt;、&gt;=、&lt;、&lt;=、!=（不等于）和 ==（等于）</p><p>1、注意比较时，应当使用==（等于）而不应该是=（赋值）</p><p>2、注意浮点数与整数的比较结果</p><pre class="line-numbers language-R"><code class="language-R">sqrt(2) ^ 2 == 2#> [1] FALSE1/49 * 49 == 1#> [1] FALSE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>3、比较浮点数是否相等时，不能使用 ==，而应该使用 near()</p><pre class="line-numbers language-R"><code class="language-R">near(sqrt(2) ^ 2, 2)#> [1] TRUEnear(1 / 49 * 49, 1)#> [1] TRUE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>filter() 中的多个参数是由“与”组合起来的：每个表达式都必须为真才能让一行观测包含在输出中。如果要实现其他类型的组合，你需要使用布尔运算符：&amp; 表示“与”、| 表示 “或”、! 表示“非”。下图给出了布尔运算的完整集合。</p><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-05-20%20154440.png"></p><p>找出 11 月或 12 月出发的所有航班：</p><pre><code>dplyr::filter(nycflights13::flights, month == 11 | month == 12)</code></pre><p><font color="red"><strong>注意这里不能写成month==11|12，这样返回的结果是一个布尔值，也就是TRUE（1），即filter是要搜寻1月份的数据。</strong></font></p><p>此外还有一种简写方式，x %in% y。这样会选取出 x 是 y 中的一个值时的所有行.</p><pre class="line-numbers language-R"><code class="language-R">nov_dec <- dplyr::filter(nycflights13::flights, month %in% c(11, 12))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以使用德摩根定律将复杂的筛选条件进行简化：!(x &amp; y) 等价于 !x | !y、!(x |  y) 等价于 !x &amp; !y。例如，如果想要找出延误时间（到达或出发）不多于 2 小时的航班， 那么使用以下两种筛选方式均可：</p><pre class="line-numbers language-R"><code class="language-R">dplyr::filter(nycflights13::flights, !(arr_delay > 120 | dep_delay > 120))dplyr::filter(nycflights13::flights, arr_delay <= 120, dep_delay <= 120)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h4><p>NA 表示未知的值，或称 NA（not available，不可用）。如果运算中包含了未知值，那么运算结果一般来说也是个未知值：</p><pre class="line-numbers language-R"><code class="language-R">NA > 5#> [1] NA10 == NA#> [1] NANA + 10#> [1] NANA / 2#> [1] NA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最令人费解的是以下这个结果：</p><pre class="line-numbers language-R"><code class="language-R">NA == NA#> [1] NA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们可以这么理解：</p><pre class="line-numbers language-R"><code class="language-R"># 令x为Mary的年龄。我们不知道她有多大。x <- NA# 令y为John的年龄。我们不知道他有多大。y <- NA# John和Mary的年龄是相同的吗？x == y#> [1] NA# 我们不知道！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果想要确定一个值是否为缺失值，可以使用 is.na() 函数：</p><pre class="line-numbers language-R"><code class="language-R">is.na(x)#> [1] TRUE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>filter() 只能筛选出条件为 TRUE 的行；它会排除那些条件为 FALSE 和 NA 的行。如果想保留缺失值，可以明确指出：</p><pre class="line-numbers language-R"><code class="language-R">df <- tibble(x = c(1, NA, 3))filter(df, x > 1)#> # A tibble: 1 × 1#> x#> <dbl>#> 1 3filter(df, is.na(x) | x > 1)#> # A tibble: 2 × 1#> x#> <dbl>#> 1 NA#> 2 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用arrange-排列行"><a href="#使用arrange-排列行" class="headerlink" title="使用arrange()排列行"></a>使用arrange()排列行</h3><p>arrange（）与filter（）工作方式类似，但arrange（）不是选择行，而是改变行的顺序。它接受一个数据框和一组作为排序依据的列名（或者更复杂的表达式）作为参数。 如果列名不只一个，那么就使用后面的列在前面排序的基础上继续排序：</p><pre class="line-numbers language-R"><code class="language-R">dplyr::arrange(nycflights13::flights, year, month, day)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 desc() 可以按列进行降序排序：</p><pre class="line-numbers language-R"><code class="language-R">dplyr::arrange(nycflights13::flights, desc(arr_delay))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>缺失值总是排在最后：</p><pre class="line-numbers language-R"><code class="language-R">df <- dplyr::tibble(x = c(5, 2, NA))dplyr::arrange(df, x)#> # A tibble: 3 × 1#> x#> <dbl>#> 1 2#> 2 5#> 3 NA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-R"><code class="language-R">arrange(df, desc(x))#> # A tibble: 3 × 1#> x#> <dbl>#> 1 5#> 2 2#> 3 NA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用select（）选择列"><a href="#使用select（）选择列" class="headerlink" title="使用select（）选择列"></a>使用select（）选择列</h3><p>通过基于变量名的操作，select() 函数可以让你 快速生成一个有用的变量子集。</p><pre class="line-numbers language-R"><code class="language-R"># 按名称选择列dplyr::select(nycflights13::flights, year, month, day)# A tibble: 336,776 × 3    year month   day   <int> <int> <int> 1  2013     1     1 2  2013     1     1 3  2013     1     1 4  2013     1     1 5  2013     1     1 6  2013     1     1 7  2013     1     1 8  2013     1     1 9  2013     1     110  2013     1     1# … with 336,766 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-R"><code class="language-R"># 选择“year”和“day”之间的所有列（包括“year”和“day”）dplyr::select(nycflights13::flights, year:day)# A tibble: 336,776 × 3    year month   day   <int> <int> <int> 1  2013     1     1 2  2013     1     1 3  2013     1     1 4  2013     1     1 5  2013     1     1 6  2013     1     1 7  2013     1     1 8  2013     1     1 9  2013     1     110  2013     1     1# … with 336,766 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-R"><code class="language-R"># 选择不在“year”和“day”之间的所有列（不包括“year”和“day”）dplyr::select(nycflights13::flights, -(year:day))# A tibble: 336,776 × 16   dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier flight tail_num origin dest  air_time distance  hour minute time_hour                <int>          <int>     <dbl>    <int>          <int>     <dbl> <chr>    <int> <chr>   <chr>  <chr>    <dbl>    <dbl> <dbl>  <dbl> <dttm>              1      517            515         2      830            819        11 UA        1545 N14228  EWR    IAH        227     1400     5     15 2013-01-01 05:00:00 2      533            529         4      850            830        20 UA        1714 N24211  LGA    IAH        227     1416     5     29 2013-01-01 05:00:00 3      542            540         2      923            850        33 AA        1141 N619AA  JFK    MIA        160     1089     5     40 2013-01-01 05:00:00 4      544            545        -1     1004           1022       -18 B6         725 N804JB  JFK    BQN        183     1576     5     45 2013-01-01 05:00:00 5      554            600        -6      812            837       -25 DL         461 N668DN  LGA    ATL        116      762     6      0 2013-01-01 06:00:00 6      554            558        -4      740            728        12 UA        1696 N39463  EWR    ORD        150      719     5     58 2013-01-01 05:00:00 7      555            600        -5      913            854        19 B6         507 N516JB  EWR    FLL        158     1065     6      0 2013-01-01 06:00:00 8      557            600        -3      709            723       -14 EV        5708 N829AS  LGA    IAD         53      229     6      0 2013-01-01 06:00:00 9      557            600        -3      838            846        -8 B6          79 N593JB  JFK    MCO        140      944     6      0 2013-01-01 06:00:0010      558            600        -2      753            745         8 AA         301 N3ALAA  LGA    ORD        138      733     6      0 2013-01-01 06:00:00# … with 336,766 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 select () 函数中还可以使用一些辅助函数。</p><ul><li><p>starts_with(“abc”)：匹配以“abc”开头的名称。 </p></li><li><p>ends_with(“xyz”)：匹配以“xyz”结尾的名称。</p></li><li><p>contains(“ijk”)：匹配包含“ijk”的名称。 </p></li><li><p>matches(“(.)\1”)：选择匹配正则表达式的那些变量。这个正则表达式会匹配名称中有重复字符的变量。后面会介绍正则表达式的知识。 </p></li><li><p>num_range(“x”, 1:3)：匹配 x1、x2 和 x3。</p></li></ul><p>举个栗子：</p><pre class="line-numbers language-R"><code class="language-R">dplyr::select(nycflights13::flights,contains("time"))# A tibble: 336,776 × 6   dep_time sched_dep_time arr_time sched_arr_time air_time time_hour                <int>          <int>    <int>          <int>    <dbl> <dttm>              1      517            515      830            819      227 2013-01-01 05:00:00 2      533            529      850            830      227 2013-01-01 05:00:00 3      542            540      923            850      160 2013-01-01 05:00:00 4      544            545     1004           1022      183 2013-01-01 05:00:00 5      554            600      812            837      116 2013-01-01 06:00:00 6      554            558      740            728      150 2013-01-01 05:00:00 7      555            600      913            854      158 2013-01-01 06:00:00 8      557            600      709            723       53 2013-01-01 06:00:00 9      557            600      838            846      140 2013-01-01 06:00:0010      558            600      753            745      138 2013-01-01 06:00:00# … with 336,766 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>select() 可以重命名变量，但尽量避免这样做，因为这样会丢掉所有未明确提及的变量。我们应该使用 select() 函数的变体 rename() 函数来重命名变量，以保留所有未明确提及的变量：</p><pre class="line-numbers language-R"><code class="language-R">dplyr::rename(nycflights13::flights, tail_num = tailnum)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>另一种用法是将 select() 函数和 everything() 辅助函数结合起来使用。当想要将几个变量移到数据框开头时，这种用法非常奏效：</p><pre class="line-numbers language-R"><code class="language-R">dplyr::select(nycflights13::flights, time_hour, air_time, everything())# A tibble: 336,776 × 19   time_hour           air_time  year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier flight tailnum origin dest  distance  hour   <dttm>                 <dbl> <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>     <dbl> <chr>    <int> <chr>   <chr>  <chr>    <dbl> <dbl> 1 2013-01-01 05:00:00      227  2013     1     1      517            515         2      830            819        11 UA        1545 N14228  EWR    IAH       1400     5 2 2013-01-01 05:00:00      227  2013     1     1      533            529         4      850            830        20 UA        1714 N24211  LGA    IAH       1416     5 3 2013-01-01 05:00:00      160  2013     1     1      542            540         2      923            850        33 AA        1141 N619AA  JFK    MIA       1089     5 4 2013-01-01 05:00:00      183  2013     1     1      544            545        -1     1004           1022       -18 B6         725 N804JB  JFK    BQN       1576     5 5 2013-01-01 06:00:00      116  2013     1     1      554            600        -6      812            837       -25 DL         461 N668DN  LGA    ATL        762     6 6 2013-01-01 05:00:00      150  2013     1     1      554            558        -4      740            728        12 UA        1696 N39463  EWR    ORD        719     5 7 2013-01-01 06:00:00      158  2013     1     1      555            600        -5      913            854        19 B6         507 N516JB  EWR    FLL       1065     6 8 2013-01-01 06:00:00       53  2013     1     1      557            600        -3      709            723       -14 EV        5708 N829AS  LGA    IAD        229     6 9 2013-01-01 06:00:00      140  2013     1     1      557            600        -3      838            846        -8 B6          79 N593JB  JFK    MCO        944     610 2013-01-01 06:00:00      138  2013     1     1      558            600        -2      753            745         8 AA         301 N3ALAA  LGA    ORD        733     6# … with 336,766 more rows, and 1 more variable: minute <dbl><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用mutate-添加新变量"><a href="#使用mutate-添加新变量" class="headerlink" title="使用mutate()添加新变量"></a>使用mutate()添加新变量</h3><p>有时还经常需要添加新列，新列是现有列的函数。这就是 mutate() 函数的作用。</p><p>mutate() 总是将新列添加在数据集的最后，因此我们需要先创建一个更狭窄的数据集，以便能够看到新变量。当使用 RStudio 时，查看所有列的最简单的方法就是使用 View() 函数：</p><pre class="line-numbers language-R"><code class="language-R">#首先抽取出一个更小的数据集flights_sml，该数据集由year到day列，以“delay”结束的列、distance列、air_time列组成flights_sml <- dplyr::select(nycflights13::flights, year:day, ends_with("delay"), distance, air_time)dplyr::mutate(flights_sml, gain = arr_delay - dep_delay, speed = distance / air_time * 60)# 使用mutate（）新增gain和speed两列# A tibble: 336,776 × 9    year month   day dep_delay arr_delay distance air_time  gain speed   <int> <int> <int>     <dbl>     <dbl>    <dbl>    <dbl> <dbl> <dbl> 1  2013     1     1         2        11     1400      227     9  370. 2  2013     1     1         4        20     1416      227    16  374. 3  2013     1     1         2        33     1089      160    31  408. 4  2013     1     1        -1       -18     1576      183   -17  517. 5  2013     1     1        -6       -25      762      116   -19  394. 6  2013     1     1        -4        12      719      150    16  288. 7  2013     1     1        -5        19     1065      158    24  404. 8  2013     1     1        -3       -14      229       53   -11  259. 9  2013     1     1        -3        -8      944      140    -5  405.10  2013     1     1        -2         8      733      138    10  319.# … with 336,766 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一旦创建，新列就可以立即使用：</p><pre class="line-numbers language-R"><code class="language-R">dplyr::mutate(flights_sml, gain = arr_delay - dep_delay, hours = air_time / 60, gain_per_hour = gain / hours)# A tibble: 336,776 × 10    year month   day dep_delay arr_delay distance air_time  gain hours gain_per_hour   <int> <int> <int>     <dbl>     <dbl>    <dbl>    <dbl> <dbl> <dbl>         <dbl> 1  2013     1     1         2        11     1400      227     9 3.78           2.38 2  2013     1     1         4        20     1416      227    16 3.78           4.23 3  2013     1     1         2        33     1089      160    31 2.67          11.6  4  2013     1     1        -1       -18     1576      183   -17 3.05          -5.57 5  2013     1     1        -6       -25      762      116   -19 1.93          -9.83 6  2013     1     1        -4        12      719      150    16 2.5            6.4  7  2013     1     1        -5        19     1065      158    24 2.63           9.11 8  2013     1     1        -3       -14      229       53   -11 0.883        -12.5  9  2013     1     1        -3        -8      944      140    -5 2.33          -2.1410  2013     1     1        -2         8      733      138    10 2.3            4.35# … with 336,766 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果只想保留新变量，可以使用 transmute() 函数：</p><pre class="line-numbers language-R"><code class="language-R">dplyr::transmute(nycflights13::flights, gain = arr_delay - dep_delay, hours = air_time / 60, gain_per_hour = gain / hours)# A tibble: 336,776 × 3    gain hours gain_per_hour   <dbl> <dbl>         <dbl> 1     9 3.78           2.38 2    16 3.78           4.23 3    31 2.67          11.6  4   -17 3.05          -5.57 5   -19 1.93          -9.83 6    16 2.5            6.4  7    24 2.63           9.11 8   -11 0.883        -12.5  9    -5 2.33          -2.1410    10 2.3            4.35# … with 336,766 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="常用创建函数"><a href="#常用创建函数" class="headerlink" title="常用创建函数"></a>常用创建函数</h4><p>创建新变量的多种函数可供同 mutate() 一同使用。最重要的一点是，**<font color="red">这种函数必须是向量化的：它必须接受一个向量作为输入，并返回一个向量作为输出，而且输入向量与输出向量具有同样数目的分量。</font>**下面介绍一下比较常用的创建函数。</p><ul><li><p>算术运算符：+、-、*、/、^</p><p>如果一个参数比另一个参数短，那么前者会自动扩展到同样的长度。当某个参数是单个数值时，这种方式是最有效的：air_ time / 60、hours * 60 + minute 等。</p><p>算术运算符的另一用途是与后面将学到的聚集函数结合起来使用。例如，x /  sum(x) 可以计算出各个分量在总数中的比例，y – mean(y) 可以计算出分量与均值之间的差值。</p></li><li><p>模运算符：%/% 和 %%</p><p>%/%（整数除法）和 %%（求余）满足 x == y * (x %/% y) + (x %% y)。模运算非常好用，因为它可以拆分整数。例如，在航班数据集中，你可以根据 dep_time 计算出 hour 和 minute：</p></li></ul><pre class="line-numbers language-R"><code class="language-R">dplyr::transmute(nycflights13::flights, dep_time, hour = dep_time %/% 100, minute = dep_time %% 100)# A tibble: 336,776 × 3   dep_time  hour minute      <int> <dbl>  <dbl> 1      517     5     17 2      533     5     33 3      542     5     42 4      544     5     44 5      554     5     54 6      554     5     54 7      555     5     55 8      557     5     57 9      557     5     5710      558     5     58# … with 336,766 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>对数函数：log()、log2() 和 log10()</p><p>在处理取值范围横跨多个数量级的数据时，对数是特别有用的一种转换方式。它还可以 将乘法转换成加法。</p><p>其他条件相同的情况下，推荐使用 log2() 函数，因为很容易对其进行解释：对数标度的数值增加 1 个单位，意味着初始数值加倍；减少 1 个单位，则意味着初始数值减半。</p></li><li><p>偏移函数</p><p>lead() 和 lag() 函数可以返回一个序列的领先值和滞后值。它们可以计算出序列的移动差值（如 x – lag(x)）或发现序列何时发生了变化（x != lag(x)）。它们与 group_by() 组合使用时特别有用，你很快就会学到 group_by() 这个函数：</p></li></ul><pre class="line-numbers language-R"><code class="language-R">(x <- 1:10)#> [1] 1 2 3 4 5 6 7 8 9 10> dplyr::lag(x) [1] NA  1  2  3  4  5  6  7  8  9> dplyr::lead(x) [1]  2  3  4  5  6  7  8  9 10 NA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>累加和滚动聚合</p><p>R 提供了计算累加和、累加积、累加最小值和累加最大值的函数：cumsum()、cumprod()、 commin() 和 cummax()；dplyr 还提供了 cummean() 函数以计算累加均值。如果想要计算 滚动聚合（即滚动窗口求和），那么可以尝试使用 RcppRoll 包：</p></li></ul><pre class="line-numbers language-R"><code class="language-R">x#> [1] 1 2 3 4 5 6 7 8 9 10cumsum(x)#> [1] 1 3 6 10 15 21 28 36 45 55dplyr::cummean(x)#> [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>逻辑比较：&lt;、&lt;=、&gt;、&gt;= 和 !=</p><p>如果需要进行一系列复杂的逻辑运算，那么最好将中间结果保存在新变量中，这样就可 以检查是否每一步都符合预期。</p></li><li><p>排秩</p><p>排秩函数有很多，但你应该从 min_rank() 函数（**<font color="red">有重复排名，相同值将标为同一排名，会占用多个排名序号</font>**）开始，它可以完成最常用的排秩任务 （如第一、第二、第三、第四）。默认的排秩方式是，最小的值获得最前面的名次，使用 desc(x) 可以让最大的值获得最前面的名次：</p></li></ul><pre class="line-numbers language-R"><code class="language-R">y <- c(1, 2, 2, NA, 3, 4)min_rank(y)#> [1] 1 2 2 NA 4 5min_rank(desc(y))#> [1] 5 3 3 NA 2 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果 min_rank() 无法满足需要，那么可以看一下其变体 row_number()、dense_rank()、 percent_rank()、cume_dist() 和 ntile()。可以查看它们的帮助页面以获得更多信息：</li></ul><pre class="line-numbers language-R"><code class="language-R">row_number(y)#> [1] 1 2 3 NA 4 5dense_rank(y)#> [1] 1 2 2 NA 3 4percent_rank(y)#> [1] 0.00 0.25 0.25 NA 0.75 1.00cume_dist(y)#> [1] 0.2 0.6 0.6 NA 0.8 1.0###<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用summarize-进行分组摘要"><a href="#使用summarize-进行分组摘要" class="headerlink" title="使用summarize()进行分组摘要"></a>使用summarize()进行分组摘要</h3><p>最后一个核心函数是 summarize()，它可以将数据框折叠成一行：</p><pre class="line-numbers language-R"><code class="language-R">dplyr::summarize(nycflights13::flights, delay = mean(dep_delay, na.rm = TRUE))# A tibble: 1 × 1  delay  <dbl>1  12.6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果不与 group_by() 一起使用，那么 summarize() 也就没什么大用。group_by() 可以将分析单位从整个数据集更改为单个分组。接下来，在分组后的数据框上使用 dplyr 函数时， 它们会自动地应用到每个分组。如果对按日期分组的一个数据框应用与上面完全相同的代码，那么我们就可以得到每日平均延误时间：</p><pre class="line-numbers language-R"><code class="language-R">by_day <- group_by(nycflights13::flights, year, month, day)dplyr::summarize(by_day, delay = mean(dep_delay, na.rm = TRUE))# A tibble: 365 × 4# Groups:   year, month [12]    year month   day delay   <int> <int> <int> <dbl> 1  2013     1     1 11.5  2  2013     1     2 13.9  3  2013     1     3 11.0  4  2013     1     4  8.95 5  2013     1     5  5.73 6  2013     1     6  7.15 7  2013     1     7  5.42 8  2013     1     8  2.55 9  2013     1     9  2.2810  2013     1    10  2.84# … with 355 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>group_by() 和 summarize() 的组合构成了使用 dplyr 包时最常用的操作之一：分组摘要。对此之前，先介绍一个功能强大的新概念：管道。</p><h4 id="使用管道组合多种操作"><a href="#使用管道组合多种操作" class="headerlink" title="使用管道组合多种操作"></a>使用管道组合多种操作</h4><p>假设我们想要研究每个目的地的距离和平均延误时间之间的关系。使用已经了解的 dplyr 包功能，你可能会写出以下代码：</p><pre class="line-numbers language-R"><code class="language-R">by_dest <- group_by(nycflights13::flights, dest)delay <- dplyr::summarize(by_dest, count = n(), dist = mean(distance, na.rm = TRUE), delay = mean(arr_delay, na.rm = TRUE))delay <- dplyr::filter(delay, count > 20, dest != "HNL")# 750英里内，平均延误时间会随着距离的增加而增加，接着会随着距离的增加而减少。随着飞 行距离的增加，延误时间有可能会在飞行中弥补回来吗？ggplot(data = delay, mapping = aes(x = dist, y = delay)) + geom_point(aes(size = count), alpha = 1/3) + geom_smooth(se = FALSE)#> `geom_smooth()` using method = 'loess'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="C:\Users\www\Pictures\Rplot15.png"></p><p>完成数据准备需要 3 步。 </p><p>(1) 按照目的地对航班进行分组。</p><p> (2) 进行摘要统计，计算距离、平均延误时间和航班数量。 </p><p>(3) 通过筛选除去噪声点和火奴鲁鲁机场，因为到达该机场的距离几乎是到离它最近机场的距离的 2 倍。</p><p>上述代码中，我们对中间数据框多次命名，这样会影响我们的编码速度。</p><p><strong>解决这个问题的另一种方法是使用管道，%&gt;%：</strong></p><pre class="line-numbers language-R"><code class="language-R">delays <- nycflights13::flights %>% group_by(dest) %>% summarize( count = n(), dist = mean(distance, na.rm = TRUE), delay = mean(arr_delay, na.rm = TRUE)) %>%dplyr::filter(count > 20, dest != "HNL")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这使得代码具有更好的可读性。你可以将其读作一串命令式语句：分组，然后摘要统计，然后进行筛选。在阅读代码时，%&gt;% 最好读作“然后”。举个栗子：</p><p>x %&gt;% f(y) 会转换为 f(x, y)</p><p>x %&gt;% f(y) %&gt;% g(z) 会转换为 g(f(x,  y), z)，以此类推。</p><p>支持管道操作是 tidyverse 中的 R 包的核心原则之一。唯一的例外就是 ggplot2：它是在发现管道方式前开发的。ggplot2 的下一个版本 ggvis 支持管道操作，遗憾的是其还没有达到成熟完备的程度。</p><h4 id="缺失值-1"><a href="#缺失值-1" class="headerlink" title="缺失值"></a>缺失值</h4><p>前面使用了参数 na.rm，你应该非常想要知道其含义。如果没有设置这个参数，会发生什么情况呢？</p><pre class="line-numbers language-R"><code class="language-R">flights %>% group_by(year, month, day) %>% summarize(mean = mean(dep_delay,na.rm=TRUE))# A tibble: 365 × 4# Groups:   year, month [12]    year month   day  mean   <int> <int> <int> <dbl> 1  2013     1     1 11.5  2  2013     1     2 13.9  3  2013     1     3 11.0  4  2013     1     4  8.95 5  2013     1     5  5.73 6  2013     1     6  7.15 7  2013     1     7  5.42 8  2013     1     8  2.55 9  2013     1     9  2.2810  2013     1    10  2.84# … with 355 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-R"><code class="language-R">flights %>% group_by(year, month, day) %>% summarize(mean = mean(dep_delay))# A tibble: 365 × 4# Groups:   year, month [12]    year month   day  mean   <int> <int> <int> <dbl> 1  2013     1     1    NA 2  2013     1     2    NA 3  2013     1     3    NA 4  2013     1     4    NA 5  2013     1     5    NA 6  2013     1     6    NA 7  2013     1     7    NA 8  2013     1     8    NA 9  2013     1     9    NA10  2013     1    10    NA# … with 355 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们会得到很多缺失值！这是因为聚合函数遵循缺失值的一般规则：如果输入中有缺失值，那么输出也会是缺失值。好在所有聚合函数都有一个 na.rm 参数，它可以在计算前除去缺失值。</p><p>在这个示例中，缺失值表示取消的航班，我们也可以通过先去除取消的航班来解决缺失值 问题。保存这个数据集，以便我们可以在接下来的几个示例中继续使用：</p><pre class="line-numbers language-R"><code class="language-R">not_cancelled <- flights %>% filter(!is.na(dep_delay), !is.na(arr_delay))not_cancelled %>% group_by(year, month, day) %>% summarize(mean = mean(dep_delay))# A tibble: 365 × 4# Groups:   year, month [12]    year month   day  mean   <int> <int> <int> <dbl> 1  2013     1     1 11.4  2  2013     1     2 13.7  3  2013     1     3 10.9  4  2013     1     4  8.97 5  2013     1     5  5.73 6  2013     1     6  7.15 7  2013     1     7  5.42 8  2013     1     8  2.56 9  2013     1     9  2.3010  2013     1    10  2.84# … with 355 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h4><p>聚合操作中包括一个计数n()或非缺失值的计数sum(!is_na())。例如，我们查看一下具有最长平均延误时间的飞机（通过机尾编号进行识别）：</p><pre class="line-numbers language-R"><code class="language-R">delays <- not_cancelled %>% group_by(tailnum) %>% summarize( delay = mean(arr_delay) )ggplot(data = delays, mapping = aes(x = delay)) + geom_freqpoly(binwidth = 10)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="G:\R语言Markdown\Rplot16.png"></p><p>画一张航班数量和平均延误时间的散点图，以便获得更深刻的理解：</p><p><img src="G:\R语言Markdown\Rplot17.png"></p><p>当航班数量非常少时，平均延误时间的变动特别大。这张图的形状非常能够说明问题：当绘制均值（或其他摘要统计量）和分组规模的关系时，你总能看到随着样本量的增加，变动在不断减小。</p><p><img src="G:\R语言Markdown\Rplot18.png"></p><p>这种数据模式还有另外一种常见的变体。我们看一下棒球击球手的平均表现与击球次数之间的关系。我们使用 Lahman 包中的数据来计算大联盟的每个棒球队员的打击率（安打数 / 打数）.</p><p>当我绘制出击球手的能力（用打击率 ba 衡量）与击球机会数量（用打数 ab 衡量）之间的关系时，你可以看到两种模式。</p><ul><li>同上，数据点越多，聚合值的变动就越小。</li><li>能力（ba）和击球机会数量（ab）之间存在正相关。这是因为球队会控制击球手的出场， 很显然，球队会优先选择最好的队员。</li></ul><pre class="line-numbers language-R"><code class="language-R"># 转换成tibble，以便输出更美观# 装载Lahman包出错，Lahman<-"https://cran.r-project.org/src/contrib/Lahman_10.0-1.tar.gz"install.packages(Lahman, repos=NULL, type="source")batting <- as_tibble(Lahman::Batting)batters <- batting %>% group_by(playerID) %>% summarize( ba = sum(H, na.rm = TRUE) / sum(AB, na.rm = TRUE), ab = sum(AB, na.rm = TRUE) )batters %>% filter(ab > 100) %>% ggplot(mapping = aes(x = ab, y = ba)) + geom_point() + geom_smooth(se = FALSE)#> `geom_smooth()` using method = 'gam'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="G:\R语言Markdown\Rplot19.png"></p><p>这对球员排名也有重要影响。如果只是使用 desc(ba) 进行排序，明显受益的将是具有最好打击率的球员，而不是能力最高的球员：</p><pre class="line-numbers language-R"><code class="language-R">batters %>% arrange(desc(ba))# A tibble: 20,166 × 3   playerID     ba    ab   <chr>     <dbl> <int> 1 abramge01     1     1 2 alberan01     1     1 3 banisje01     1     1 4 bartocl01     1     1 5 bassdo01      1     1 6 birasst01     1     2 7 bruneju01     1     1 8 burnscb01     1     1 9 cammaer01     1     110 campsh01      1     1# … with 20,156 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="常用的摘要函数"><a href="#常用的摘要函数" class="headerlink" title="常用的摘要函数"></a>常用的摘要函数</h4><p>只使用均值、计数和求和是远远不够的，R 中还提供了很多其他的常用的摘要函数。</p><ul><li><p>位置度量</p><p>已经使用过 mean(x)，但 median(x) 也非常有用。均值是总数除以个数；中位数则是这样一个值：50% 的 x 大于它，同时 50% 的 x 小于它。</p><p>有时候需要将聚合函数和逻辑筛选组合起来使用。</p></li></ul><pre class="line-numbers language-R"><code class="language-R">not_cancelled %>% group_by(year, month, day) %>% summarize( # 平均延误时间： avg_delay1 = mean(arr_delay), # 平均正延误时间： avg_delay2 = mean(arr_delay[arr_delay > 0]) ) # A tibble: 365 × 5# Groups:   year, month [12]    year month   day avg_delay1 avg_delay2   <int> <int> <int>      <dbl>      <dbl> 1  2013     1     1     12.7         32.5 2  2013     1     2     12.7         32.0 3  2013     1     3      5.73        27.7 4  2013     1     4     -1.93        28.3 5  2013     1     5     -1.53        22.6 6  2013     1     6      4.24        24.4 7  2013     1     7     -4.95        27.8 8  2013     1     8     -3.23        20.8 9  2013     1     9     -0.264       25.610  2013     1    10     -5.90        27.3# … with 355 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>分散程度度量：sd(x)、IQR(x) 和 mad(x)</li></ul><p>均方误差（又称标准误差，standard deviation，sd）是分散程度的标准度量方式。四分位距 IQR() 和绝对中位差 mad(x) 基本等价，更适合有离群点的情况：</p><pre class="line-numbers language-R"><code class="language-R"># 为什么到某些目的地的距离比到其他目的地更多变？not_cancelled %>% group_by(dest) %>% summarize(distance_sd = sd(distance)) %>% arrange(desc(distance_sd))# A tibble: 104 × 2   dest  distance_sd   <chr>       <dbl> 1 EGE         10.5  2 SAN         10.4  3 SFO         10.2  4 HNL         10.0  5 SEA          9.98 6 LAS          9.91 7 PDX          9.87 8 PHX          9.86 9 LAX          9.6610 IND          9.46# … with 94 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>秩的度量：min(x)、quantile(x, 0.25) 和 max(x)</li></ul><p>分位数是中位数的扩展。例如，quantile(x, 0.25) 会找出 x 中按从小到大顺序大于前 25% 而小于后 75% 的值：</p><pre class="line-numbers language-R"><code class="language-R"># 每天最早和最晚的航班何时出发？not_cancelled %>% group_by(year, month, day) %>% summarize( first = min(dep_time), last = max(dep_time) )# A tibble: 365 × 5# Groups:   year, month [12]    year month   day first  last   <int> <int> <int> <int> <int> 1  2013     1     1   517  2356 2  2013     1     2    42  2354 3  2013     1     3    32  2349 4  2013     1     4    25  2358 5  2013     1     5    14  2357 6  2013     1     6    16  2355 7  2013     1     7    49  2359 8  2013     1     8   454  2351 9  2013     1     9     2  225210  2013     1    10     3  2320# … with 355 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>定位度量：first(x)、nth(x, 2) 和 last(x)</li></ul><p>这几个函数的作用与 x[1]、x[2] 和 x[length(x)] 相同，只是当定位不存在时（比如尝试从只有两个元素的分组中得到第三个元素），前者允许你设置一个默认值。例如，我们可以找出每天最早和最晚出发的航班：</p><pre class="line-numbers language-R"><code class="language-R">not_cancelled %>% group_by(year, month, day) %>% summarize( first_dep = first(dep_time), last_dep = last(dep_time) )# A tibble: 365 × 5# Groups:   year, month [12]    year month   day first_dep last_dep   <int> <int> <int>     <int>    <int> 1  2013     1     1       517     2356 2  2013     1     2        42     2354 3  2013     1     3        32     2349 4  2013     1     4        25     2358 5  2013     1     5        14     2357 6  2013     1     6        16     2355 7  2013     1     7        49     2359 8  2013     1     8       454     2351 9  2013     1     9         2     225210  2013     1    10         3     2320# … with 355 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些函数对筛选操作进行了排秩方面的补充。筛选会返回所有变量，每个观测在单独的一行中：</p><pre class="line-numbers language-R"><code class="language-R">not_cancelled %>% group_by(year, month, day) %>% mutate(r = min_rank(desc(dep_time))) %>% filter(r %in% range(r))# A tibble: 770 × 20# Groups:   year, month, day [365]    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier flight tailnum origin dest  air_time   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>     <dbl> <chr>    <int> <chr>   <chr>  <chr>    <dbl> 1  2013     1     1      517            515         2      830            819        11 UA        1545 N14228  EWR    IAH        227 2  2013     1     1     2356           2359        -3      425            437       -12 B6         727 N588JB  JFK    BQN        186 3  2013     1     2       42           2359        43      518            442        36 B6         707 N580JB  JFK    SJU        189 4  2013     1     2     2354           2359        -5      413            437       -24 B6         727 N789JB  JFK    BQN        180 5  2013     1     3       32           2359        33      504            442        22 B6         707 N763JB  JFK    SJU        193 6  2013     1     3     2349           2359       -10      434            445       -11 B6         739 N729JB  JFK    PSE        199 7  2013     1     4       25           2359        26      505            442        23 B6         707 N554JB  JFK    SJU        194 8  2013     1     4     2358           2359        -1      429            437        -8 B6         727 N599JB  JFK    BQN        189 9  2013     1     4     2358           2359        -1      436            445        -9 B6         739 N821JB  JFK    PSE        19910  2013     1     5       14           2359        15      503            445        18 B6         739 N592JB  JFK    PSE        201# … with 760 more rows, and 5 more variables: distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>, r <int><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>计数</li></ul><p>你已经见过 n()，它不需要任何参数，并返回当前分组的大小。如果想要计算出非缺失值的数量，可以使用 sum(!is.na(x))。要想计算出唯一值的数量，可以使用 n_ distinct(x)：</p><pre class="line-numbers language-R"><code class="language-R"># 哪个目的地具有最多的航空公司？not_cancelled %>% group_by(dest) %>% summarize(carriers = n_distinct(carrier)) %>% arrange(desc(carriers))# A tibble: 104 × 2   dest  carriers   <chr>    <int> 1 ATL          7 2 BOS          7 3 CLT          7 4 ORD          7 5 TPA          7 6 AUS          6 7 DCA          6 8 DTW          6 9 IAD          610 MSP          6# … with 94 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为计数太常用了，所以 dplyr 提供了一个简单的辅助函数，用于只需要计数的情况：</p><pre class="line-numbers language-R"><code class="language-R">not_cancelled %>% count(dest)# A tibble: 104 × 2   dest      n   <chr> <int> 1 ABQ     254 2 ACK     264 3 ALB     418 4 ANC       8 5 ATL   16837 6 AUS    2411 7 AVL     261 8 BDL     412 9 BGR     35810 BHM     269# … with 94 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你还可以选择提供一个加权变量。例如，你可以使用以下代码算出每架飞机飞行的总里程数（实际上就是求和）：</p><pre class="line-numbers language-R"><code class="language-R">not_cancelled %>% count(tailnum, wt = distance)# A tibble: 4,037 × 2   tailnum      n   <chr>    <dbl> 1 D942DN    3418 2 N0EGMQ  239143 3 N10156  109664 4 N102UW   25722 5 N103US   24619 6 N104UW   24616 7 N10575  139903 8 N105UW   23618 9 N107US   2167710 N108UW   32070# … with 4,027 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>逻辑值的计数和比例：sum(x &gt; 10) 和 mean(y == 0)</li></ul><p>当与数值型函数一同使用时，TRUE 会转换为 1，FALSE 会转换为 0。这使得 sum() 和 mean() 非常适用于逻辑值：sum(x) 可以找出 x 中 TRUE 的数量，mean(x) 则可以找出比例。</p><pre class="line-numbers language-R"><code class="language-R"># 多少架航班是在早上5点前出发的？（这通常表明前一天延误的航班数量）not_cancelled %>% group_by(year, month, day) %>% summarize(n_early = sum(dep_time < 500))# A tibble: 365 × 4# Groups:   year, month [12]    year month   day n_early   <int> <int> <int>   <int> 1  2013     1     1       0 2  2013     1     2       3 3  2013     1     3       4 4  2013     1     4       3 5  2013     1     5       3 6  2013     1     6       2 7  2013     1     7       2 8  2013     1     8       1 9  2013     1     9       310  2013     1    10       3# … with 355 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-R"><code class="language-R"># 延误超过1小时的航班比例是多少？not_cancelled %>% group_by(year, month, day) %>% summarize(hour_perc = mean(arr_delay > 60))# A tibble: 365 × 4# Groups:   year, month [12]    year month   day hour_perc   <int> <int> <int>     <dbl> 1  2013     1     1    0.0722 2  2013     1     2    0.0851 3  2013     1     3    0.0567 4  2013     1     4    0.0396 5  2013     1     5    0.0349 6  2013     1     6    0.0470 7  2013     1     7    0.0333 8  2013     1     8    0.0213 9  2013     1     9    0.020210  2013     1    10    0.0183# … with 355 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="按多个变量分组"><a href="#按多个变量分组" class="headerlink" title="按多个变量分组"></a>按多个变量分组</h4><p>当使用多个变量进行分组时，每次的摘要统计会用掉一个分组变量。这样就可以轻松地对数据集进行循序渐进的分析：</p><pre class="line-numbers language-R"><code class="language-R">daily <- group_by(flights, year, month, day)(per_day <- summarize(daily, flights = n()))# A tibble: 365 × 4# Groups:   year, month [12]    year month   day flights   <int> <int> <int>   <int> 1  2013     1     1     842 2  2013     1     2     943 3  2013     1     3     914 4  2013     1     4     915 5  2013     1     5     720 6  2013     1     6     832 7  2013     1     7     933 8  2013     1     8     899 9  2013     1     9     90210  2013     1    10     932# … with 355 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-R"><code class="language-R">per_month <- summarize(per_day, flights = sum(flights))# A tibble: 12 × 3# Groups:   year [1]    year month flights   <int> <int>   <int> 1  2013     1   27004 2  2013     2   24951 3  2013     3   28834 4  2013     4   28330 5  2013     5   28796 6  2013     6   28243 7  2013     7   29425 8  2013     8   29327 9  2013     9   2757410  2013    10   2888911  2013    11   2726812  2013    12   28135<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-R"><code class="language-R">per_year <- summarize(per_month, flights = sum(flights))# A tibble: 1 × 2   year flights  <int>   <int>1  2013  336776<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在循序渐进地进行摘要分析时，需要小心：使用求和与计数操作是没问题的，但如果想要 使用加权平均和方差的话，就要仔细考虑一下，在基于秩的统计数据（如中位数）上是无 法进行这些操作的。换句话说，对分组求和的结果再求和就是对整体求和，但分组中位数 的中位数可不是整体的中位数</p><h4 id="取消分组"><a href="#取消分组" class="headerlink" title="取消分组"></a>取消分组</h4><p>如果想要取消分组，并回到未分组的数据继续操作，那么可以使用 ungroup() 函数：</p><pre class="line-numbers language-R"><code class="language-R">daily %>% ungroup() %>% # 不再按日期分组 summarize(flights = n()) # 所有航班<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="分组新变量（和筛选器）"><a href="#分组新变量（和筛选器）" class="headerlink" title="分组新变量（和筛选器）"></a>分组新变量（和筛选器）</h3><p>虽然与 summarize() 函数结合起来使用是最有效的，但分组也可以与 mutate() 和 filter() 函数结合，以完成非常便捷的操作。</p><ul><li>找出每个分组中最差的成员：</li></ul><pre class="line-numbers language-R"><code class="language-R">flights_sml <- flights %>% group_by(year, month, day) %>% filter(rank(desc(arr_delay)) < 10)flights_sml# A tibble: 3,306 × 19# Groups:   year, month, day [365]    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int> 1  2013     1     1      848           1835       853     1001           1950 2  2013     1     1     1815           1325       290     2120           1542 3  2013     1     1     1842           1422       260     1958           1535 4  2013     1     1     1942           1705       157     2124           1830 5  2013     1     1     2006           1630       216     2230           1848 6  2013     1     1     2115           1700       255     2330           1920 7  2013     1     1     2205           1720       285       46           2040 8  2013     1     1     2312           2000       192       21           2110 9  2013     1     1     2343           1724       379      314           193810  2013     1     2     1244            900       224     1431           1104# … with 3,296 more rows, and 11 more variables: arr_delay <dbl>, carrier <chr>,#   flight <int>, tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>,#   distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>找出大于某个阈值的所有分组：</li></ul><pre class="line-numbers language-R"><code class="language-R">popular_dests <- flights %>% group_by(dest) %>% filter(n() > 365)popular_dests# A tibble: 332,577 × 19# Groups:   dest [77]    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int> 1  2013     1     1      517            515         2      830            819 2  2013     1     1      533            529         4      850            830 3  2013     1     1      542            540         2      923            850 4  2013     1     1      544            545        -1     1004           1022 5  2013     1     1      554            600        -6      812            837 6  2013     1     1      554            558        -4      740            728 7  2013     1     1      555            600        -5      913            854 8  2013     1     1      557            600        -3      709            723 9  2013     1     1      557            600        -3      838            84610  2013     1     1      558            600        -2      753            745# … with 332,567 more rows, and 11 more variables: arr_delay <dbl>, carrier <chr>,#   flight <int>, tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>,#   distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对数据进行标准化以计算分组指标：</li></ul><pre class="line-numbers language-R"><code class="language-R">popular_dests %>% filter(arr_delay > 0) %>% mutate(prop_delay = arr_delay / sum(arr_delay)) %>% select(year:day, dest, arr_delay, prop_delay)# A tibble: 131,106 × 6# Groups:   dest [77]    year month   day dest  arr_delay prop_delay   <int> <int> <int> <chr>     <dbl>      <dbl> 1  2013     1     1 IAH          11  0.000111  2  2013     1     1 IAH          20  0.000201  3  2013     1     1 MIA          33  0.000235  4  2013     1     1 ORD          12  0.0000424 5  2013     1     1 FLL          19  0.0000938 6  2013     1     1 ORD           8  0.0000283 7  2013     1     1 LAX           7  0.0000344 8  2013     1     1 DFW          31  0.000282  9  2013     1     1 ATL          12  0.000040010  2013     1     1 DTW          16  0.000116 # … with 131,096 more rows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分组筛选器的作用相当于分组新变量加上未分组筛选器。我一般不使用分组筛选器，除非是为了完成快速、粗略的数据处理，否则很难检查数据处理的结果是否正确。</p><p>在分组新变量和筛选器中最常使用的函数称为窗口函数（与用于统计的摘要函数相 对）。你可以在相应的使用指南中学习到更多关于窗口函数的知识：vignette(“window-functions”)。</p>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
            <tag> 数据可视化 </tag>
            
            <tag> dplyr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R4DS读书笔记（第二章、工作流：基础）</title>
      <link href="/2022/05/19/r4ds-du-shu-bi-ji-di-er-zhang-gong-zuo-liu-ji-chu/"/>
      <url>/2022/05/19/r4ds-du-shu-bi-ji-di-er-zhang-gong-zuo-liu-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="代码基础"><a href="#代码基础" class="headerlink" title="代码基础"></a>代码基础</h2><p>创建对象使用下列的形式</p><pre class="line-numbers language-R"><code class="language-R">object_name <- value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Rstudio中常使用“alt+减号”生成赋值符号“&lt;-”</p><h2 id="对象名称"><a href="#对象名称" class="headerlink" title="对象名称"></a>对象名称</h2><p>使用对象名不能有错误，区分大小写，需要严格准确，在rstudio里输入this,使用按 Ctrl+ ↑可查询所有使用了以“this”为前缀的命令。</p><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>内置函数的调用方式如下：</p><pre class="line-numbers language-R"><code class="language-R">function_name(arg1 = val1, arg2 = val2, ...)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用tab键帮助预测下一步命令、使用↑和↓箭头键来选择命令，自动补齐命令。注意弹出的浮动提示信息，它可以告诉你这个函数的参数和作用。如果想要获得更多帮助，按 F1 键就可以在右下角窗格的帮助标签页中看到详细的帮助信息。</p><p>引号和括号必须一直成对出现。RStudio 会尽力帮助我们，但如果出现不匹配，R 会显示一个 + 号提示R 在等待继续输入。</p><p>如果进行了一次赋值，R 不会显示出赋值结果。你最好立刻打印出来检查一下：</p><pre class="line-numbers language-R"><code class="language-R">y <- seq(1, 10, length.out = 5)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
            <tag> 数据可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R4DS读书笔记（第一章、使用ggplot2数据可视化）</title>
      <link href="/2022/05/18/r4ds-du-shu-bi-ji-di-yi-zhang-shi-yong-ggplot2-shu-ju-ke-shi-hua/"/>
      <url>/2022/05/18/r4ds-du-shu-bi-ji-di-yi-zhang-shi-yong-ggplot2-shu-ju-ke-shi-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="R4DS读书笔记（第一章、使用ggplot2数据可视化）"><a href="#R4DS读书笔记（第一章、使用ggplot2数据可视化）" class="headerlink" title="R4DS读书笔记（第一章、使用ggplot2数据可视化）"></a>R4DS读书笔记（第一章、使用ggplot2数据可视化）</h1><p>最近在啃Hadley Wickham大佬的经典著作，R4DS（R for Data Science，中译本：R数据科学），经典的数据科学的项目分析应当遵循以下流程，而作者将最精彩的部分也就是数据可视化内容前置，让我们率先获得学习R语言之后可以用来干什么，能做出什么样的图表。<img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E6%B5%81%E7%A8%8B%E5%9B%BE1.png"></p><pre class="line-numbers language-R"><code class="language-R">install.packages("tidyverse")#安装tidyverse这个packagelibrary(tidyverse)#加载tidyverse这个package#如果想调用某个包里的具体函数，可使用以下语法结构：package::function()#例如ggplot2::ggplot()就是调用ggplot2包中的ggplot函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><h3 id="引入mpg数据框"><a href="#引入mpg数据框" class="headerlink" title="引入mpg数据框"></a>引入mpg数据框</h3><p>使用ggplot2包中自带的mpg数据框，在console里输入mpg，可展示mpg数据的相关信息（234行观测*11列变量的数据框）</p><h3 id="创建ggplot图形"><a href="#创建ggplot图形" class="headerlink" title="创建ggplot图形"></a>创建ggplot图形</h3><pre class="line-numbers language-R"><code class="language-R">ggplot(data=mpg)+    geom_point(mapping = aes(x=displ,y=hwy))#ggplot(data=mpg) ggplot() 函数创建了一个坐标系，可以在上面添加图层，ggplot(data = mpg)创建一张空白图#函数 geom_point() 向图中添加一个点层，这样就可以创建一张散点图#ggplot2中的每个几何对象函数都有一个 mapping参数。mapping参数总是与aes()函数成对出现，aes()函数的x参数和y参数分别指定了映射到x轴的变量与映射到y轴的变量。ggplot2在data参数中寻找映射变量，本例中就是mpg。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE1.png"></p><h3 id="使用ggplot绘图的语法模板"><a href="#使用ggplot绘图的语法模板" class="headerlink" title="使用ggplot绘图的语法模板"></a>使用ggplot绘图的语法模板</h3><pre class="line-numbers language-R"><code class="language-R">ggplot(data = <DATA>) + <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))#由上面我们可以抽象出ggplot绘图的语法模板<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="图形的属性映射"><a href="#图形的属性映射" class="headerlink" title="图形的属性映射"></a>图形的属性映射</h2><p>可以向二维散点图中添加<strong>第三个变量</strong>，比如 class，方式是将它<strong>映射为图形属性</strong>。<strong>图形属性是图中对象的可视化属性，其中包括数据点的大小、形状和颜色。</strong>通过改变图形属性的值，可以用不同的方式来显示数据点。</p><pre class="line-numbers language-R"><code class="language-R">#将点的颜色映射为变量 class，从而揭示每辆汽车的类型ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = class))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%BD%B1%E5%83%8F2.png"></p><p>除了将class映射为颜色外，还可将其映射为点的大小，但此时会收到一条warning ‘Using size for a discrete variable is not advised’，将无序变量（class）映射为有序图形属性（size）不是一个很好的建议。<img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE2.png"></p><p>此外我们还可以将class映射为控制数据点<strong>透明度</strong>的alpha图形属性，也可映射为<strong>点的形状</strong></p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, alpha = class))#这里同样给出了warning：Using alpha for a discrete variable is not advised<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE3.png"></p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, shape = class))#这里同样给出了warning：1: The shape palette can deal with a maximum of 6 discrete values because more than 6 becomes difficult to discriminate; you have 7. Consider specifying shapes manually if you must have them. 2: Removed 62 rows containing missing values (geom_point)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE4.png"></p><p>默认情况下，ggplot2 只能同时使用 6 种形状，多出的变量值将不会出现在图中。</p><p>此外，我们还可以<strong>手动为几何对象设置图形属性</strong>，例如让所有的点都是<font color="blue">蓝色</font>:</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data=mpg)+    geom_point(mapping= aes(x=displ,y=hwy),color="blue")#手动设置图形属性，为几何对象函数的一个参数,需要在函数 aes() 的外部进行设置。#写代码的时候要注意，+号应放在每一行的末尾而不是开头<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE5.png"></p><h2 id="分面"><a href="#分面" class="headerlink" title="分面"></a>分面</h2><p>添加额外变量的一种方法是使用图形属性。另一种方法是<strong>将图分割成多个分面</strong>，即可以显示数据子集的子图。这种方法特别适合添加分类变量。使用函数 facet_wrap()通过单个变量对图进行分面，第一个参数是一个公式，创建公式的方式是在 ~ 符号后面加一个变量名，<strong>传递给 facet_wrap() 的变量应该是离散型的</strong></p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_wrap(~ class, nrow = 2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE6.png"></p><p>通过两个变量对图进行分面，需要在绘图命令中加入函数 facet_grid()。这个函数的 第一个参数也是一个公式，但该公式包含由 ~ 隔开的两个变量名。</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_grid(drv ~ cyl)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE7.png"></p><p>如果不想在行或列的维度进行分面，你可以使用 . 来代替变量名，例如 + facet_grid(. ~  cyl)</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_grid(.~ cyl)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE8.png"></p><h2 id="几何对象"><a href="#几何对象" class="headerlink" title="几何对象"></a>几何对象</h2><p><strong>几何对象是图中用来表示数据的几何图形对象。</strong>可以使用不同的几何对象来表示同样的数据。如下图，左侧的图使用了点几何对象，右侧的图使用了平滑曲线几何对象，以一条平滑曲线来拟合数据。</p><pre class="line-numbers language-R"><code class="language-R"># 左图ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy))# 右图ggplot(data = mpg) + geom_smooth(mapping = aes(x = displ, y = hwy))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE9.png"></p><p>我们无法设置线的形状，但是可以通过linetype设置线型</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg) + geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv))#一条线表示 drv 值为 4 的所有汽车，一条线表示 drv 值为 f 的所有汽车，另一条线表示 drv 值为 r 的所有汽车。其中 4 表示四轮驱动，f 表示前轮驱动，r 表示后轮驱动<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE10.png"></p><p>只要将一个图形属性映射为一个离散变量（如上个示例中的 linetype），ggplot2 就会自动对数据进行分组来绘制多个几何对象。</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg) + geom_smooth( mapping = aes(x = displ, y = hwy, color = drv), show.legend = FALSE )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE11.png"></p><p>此外，可以将这些几何对象的 group 图形属性设置为一个分类变量，这样 ggplot2 就会为这个分类变量的每个唯一值绘制一个独立的几何对象。</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg) + geom_smooth(mapping = aes(x = displ, y = hwy, group = drv))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE12.png"></p><p><strong>如果在同一张图中显示多个几何对象，可以向 ggplot() 函数中添加多个几何对象函数：</strong></p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + geom_smooth(mapping = aes(x = displ, y = hwy))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE13.png"></p><p>但是这么写代码的话，会显得很罗嗦，每次要往空白图上添加一次几何对象，就得重复一次aes(x=?,y=?)。<strong>避免重复的方法是将一组映射直接传递给 ggplot() 函数，ggplot2 会将这些映射作为全局映射应用到图中的每个几何对象中,下面的代码与上面的代码效果一致</strong></p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point() + geom_smooth()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果将映射放在几何对象函数中，那么 ggplot2 会将其看作这个图层的局部映射，它将使用这些映射扩展或覆盖全局映射，但仅对该图层有效。这样一来，我们就可以在不同的图层中显示不同的图形属性：</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point(mapping = aes(color = class)) + geom_smooth()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE14.png"></p><p>同理，为不同的图层可以分别指定不同的数据</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point(mapping = aes(color = class)) + geom_smooth(color="green")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE15.png"></p><h2 id="统计变换"><a href="#统计变换" class="headerlink" title="统计变换"></a>统计变换</h2><p>使用基本的geom_bar() 函数可绘制基本的条形图，diamonds 数据集是 ggplot2 的内置数据集，大约包含 54 000 颗钻石的信息，每颗钻石具有 price、carat、color、 clarity 和 cut 变量。</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut))#按照 cut 变量分组的各种钻石的总数量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE16.png"></p><p>前面的散点图是用来描绘数据集已有原始数据信息的。但是y轴上的count不是diamonds的变量，这里描述产生的新数据使用的是条形图。</p><ul><li><p>条形图、直方图和频率多边形图可以对数据进行分箱（<strong>数据分箱操作</strong>），然后绘制出分箱数量和落在每个分箱的数据点的数量。</p></li><li><p>平滑曲线会为数据拟合一个模型，然后绘制出<strong>模型预测值</strong>。</p></li><li><p>箱线图可以计算出数据分布的多种摘要统计量（<strong>计算多种统计量</strong>），并显示一个特殊形式的箱体。</p></li></ul><p>绘图时用来<strong>计算新数据的算法称为 stat（statistical transformation，统计变换）</strong>。</p><p>通常来说，几何对象函数和统计变换函数可以互换使用。例如，你可以使用 stat_count() 替换 geom_bar() 来重新生成前面那张图：</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = diamonds) + stat_count(mapping = aes(x = cut))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>显式使用某种统计变换的 3 个原因如下:</p><ul><li><p>覆盖默认的统计变换。在以下代码中，将 geom_bar() 函数的统计变换从计数（默认值）修改为标识。这样就可以将条形的高度映射为 y 轴变量的初始值。</p><pre class="line-numbers language-R"><code class="language-R">demo <- tribble( ~a, ~b, "bar_1", 20, "bar_2", 30, "bar_3", 40)ggplot(data = demo) + geom_bar( mapping = aes(x = a, y = b), stat = "identity" )#不同于前面计数才能生成数据，条形图高度数据已经存在于数据集中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot.png"></p></li><li><p>覆盖从统计变换生成的变量到图形属性的默认映射。例如，你或许想显示一 张表示比例（而不是计数）的条形图：</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = diamonds) + geom_bar( mapping = aes(x = cut, y = ..prop.., group = 1) )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%9B%BE17.png"></p><ul><li><p>想要在代码中强调统计变换。例如，你可以使用 stat_summary() 函数将人们的注意力吸引到你计算出的那些摘要统计量上。stat_summary() 函数为 x 的每个唯一值计算 y 值的摘要统计：</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = diamonds) + stat_summary( mapping = aes(x = cut, y = depth), fun.ymin = min, fun.ymax = max, fun.y = median)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="位置调整"><a href="#位置调整" class="headerlink" title="位置调整"></a>位置调整</h2><p>在这里，条形图可使用使用color或者fill来上色，下面展示两者的不同</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, color = cut))ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = cut))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot01.png" style="zoom:80%;" align="center"><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot02.png" style="zoom:80%;" align="center"><p><strong>注意，如果将 fill 图形属性映射到另一个变量（如 clarity），那么条形会自动分块堆叠起来。每个彩色矩形表示 cut 和 clarity 的一种组合。</strong></p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = clarity))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot03.png"></p><p>这种堆叠是由 position 参数设定的位置调整功能自动完成的。如果不想生成堆叠式条形图，你还可以使用以下 3 种选项之一：”identity”、”fill” 和 “dodge”。</p><ul><li><p>position = “identity” 将每个对象直接显示在图中。这种方式不太适合条形图，因为 条形会彼此重叠。为了让重叠部分能够显示出来，我们可以设置 alpha 参数为一个较小 的数，从而使得条形略微透明；或者设定 fill = NA，让条形完全透明：</p><pre class="line-numbers language-R"><code class="language-R">ggplot( data = diamonds, mapping = aes(x = cut, fill = clarity)) + geom_bar(alpha = 1/5, position = "identity")ggplot( data = diamonds, mapping = aes(x = cut, color = clarity)) + geom_bar(fill = NA, position = "identity")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot04.png"></p></li><li><p>position = “fill” 的效果与堆叠相似，但每组堆叠条形具有同样的高度，因此这种条形图可以非常轻松地比较各组间的比例：</p><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot05.png"></p></li><li><p>position = “dodge” 将每组中的条形依次并列放置，这样可以非常轻松地比较每个条形表示的具体数值：</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = diamonds) + geom_bar( mapping = aes(x = cut, fill = clarity), position = "dodge" )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot06.png"></p></li></ul><p>此外还有一种关于散点图的位置调整，在一个网格上，很多点彼此重叠。这个问题称为<strong>过绘制</strong>。通过将位置调整方式设为“抖动”，可以避免这种网格化排列。position = “jitter” 为每个数据点添加一个很小的随机扰动，这样就可以将重叠的点分散开来</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg) + geom_point( mapping = aes(x = displ, y = hwy), position = "jitter" )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot07.png" style="zoom:80%;" align="center"><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot08.png" style="zoom:80%;" align="center"><h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><p>默认坐标系是笛卡儿直角坐标系，可以通过其 独立作用的 x 坐标和 y 坐标找到每个数据点。</p><ul><li><p>coord_flip() 函数可以交换 x 轴和 y 轴。当想要绘制水平箱线图时，这非常有用。它也非常适合使用长标签，但要想在 x 轴上不重叠地安排好它们是非常困难的：</p><pre class="line-numbers language-R"><code class="language-R">ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + geom_boxplot()ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + geom_boxplot() + coord_flip()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot09.png" style="zoom:80%;" align="center"><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot10.png" style="zoom:80%;" align="center"></li><li><p>coord_quickmap() 函数可以为地图设置合适的纵横比。当使用 ggplot2 绘制空间数据时， 这个函数特别重要。</p><pre class="line-numbers language-R"><code class="language-R">nz <- map_data("nz")ggplot(nz, aes(long, lat, group = group)) + geom_polygon(fill = "white", color = "black")ggplot(nz, aes(long, lat, group = group)) + geom_polygon(fill = "white", color = "black") + coord_quickmap()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot11.png" style="zoom:80%;" align="center"><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot12.png" style="zoom:80%;" align="center"></li><li><p>coord_polar() 函数使用极坐标系。极坐标系可以揭示出条形图和鸡冠花图间的一种有趣联系：</p><pre class="line-numbers language-R"><code class="language-R">bar <- ggplot(data = diamonds) + geom_bar( mapping = aes(x = cut, fill = cut), show.legend = FALSE, width = 1 ) + theme(aspect.ratio = 1) + labs(x = NULL, y = NULL)bar + coord_flip()bar + coord_polar()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot13.png" style="zoom:80%;" align="center"><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/Rplot14.png" style="zoom:80%;" align="center"></li></ul><h2 id="图形分层语法"><a href="#图形分层语法" class="headerlink" title="图形分层语法"></a>图形分层语法</h2><p>通过前面的绘制散点图、条形图和箱线图，我们掌握了使用 ggplot2 绘制任何类型图形的基础知识。</p><p>这里我们给出在前面的代码模板中添加位置调整、统计变换、坐标系和分面，给出一般情况下的使用ggplot2绘图的语法模板</p><pre class="line-numbers language-R"><code class="language-R"># ggplot(data = <<data>>) +# <<GEOM_FUNCTION>>(# mapping = aes(<<MAPPINGS>>),# stat = <<STAT>>,# position = <<POSITION>># ) +# <<COORDINATE_FUNCTION>> +# <<FACET_FUNCTION>><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新模板有 7 个参数，即模板中尖括号内的部分。但实际上，绘图时几乎不需要提供所有的 7 个参数，因为除了数据、映射和几何对象函数，ggplot2 为所有其他参数提供了非常有用的默认设置。</p><p><strong>将任何图形精确地描述为数据集、几何对象、映射集合、统计变换、位置调整、坐标系和分面模式的一个组合，图形语法正是基于这样的深刻理解构建出来的。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
            <tag> 数据可视化 </tag>
            
            <tag> ggplot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建博客杂谈</title>
      <link href="/2022/05/11/da-jian-bo-ke-za-tan/"/>
      <url>/2022/05/11/da-jian-bo-ke-za-tan/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建博客杂谈"><a href="#搭建博客杂谈" class="headerlink" title="搭建博客杂谈"></a>搭建博客杂谈</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>坦白说，这次注册的域名的命名确实有玩梗的成分在：<a href="https://flying2the.top/">https://flying2the.top</a> （当然也是方便记忆了）</p><h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p>本地安装<a href="https://nodejs.org/en/">Node.js (nodejs.org)</a></p><p>进入本地终端，使用下列命令检查是否安装成功</p><pre class="line-numbers language-shell"><code class="language-shell">node -vnpm -vnpm config set registry https://registry.npm.taobao.org #添加国内镜像源<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>本地安装<a href="https://git-scm.com/downloads">Git - Downloads (git-scm.com)</a></p><p>进入终端，检验git是否正确安装：</p><pre class="line-numbers language-shell"><code class="language-shell">git --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="注册GitHub账号，创建一个新repo"><a href="#注册GitHub账号，创建一个新repo" class="headerlink" title="注册GitHub账号，创建一个新repo"></a>注册GitHub账号，创建一个新repo</h2><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/repo.png"></p><p>选择GitHub pages主题</p><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/theme.png"></p><h2 id="本地安装hexo"><a href="#本地安装hexo" class="headerlink" title="本地安装hexo"></a>本地安装hexo</h2><p>新建一个blog文件夹，该目录下右键点击<code>Git Bash Here</code>，打开git的shell，输入<code>npm i hexo-cli -g</code>安装Hexo，</p><p>安装完后输入<code>hexo -v</code>验证是否安装成功，输入<code>hexo init</code>初始化文件夹，接着输入<code>npm install</code>安装必备的组件。</p><p>最常用的几个命令：</p><pre class="line-numbers language-shell"><code class="language-shell">hexo g #本地buildhexo s #本地启动服务，可通过本地的4000端口预览hexo d #deploy到GitHub服务器上<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="本地生成密钥"><a href="#本地生成密钥" class="headerlink" title="本地生成密钥"></a>本地生成密钥</h2><p>注册自有的Github账号，右键打开git bash，然后输入下面命令：</p><pre class="line-numbers language-shell"><code class="language-shell">git config --global user.name "GuoYu2022"git config --global user.email "yg9655@icloud.com"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后生成密钥SSH key：</p><pre class="line-numbers language-shell"><code class="language-shell">ssh-keygen -t rsa -C "yg9655@icloud.com"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>GitHub的设置里面新建一个SSH，在bash中输入</p><pre class="line-numbers language-shell"><code class="language-shell">cat ~/.ssh/id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将读取出的密钥信息复制到GitHub的SSH里面</p><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-05-11%20143240.png"></p><p>输入<code>ssh -T git@github.com</code>，如果出现用户名，说明已经成功</p><p><img src="https://raw.githubusercontent.com/GuoYu2022/BlogImg/main/img/1.png"></p><h2 id="执行Hexo-d报错Spawn-failed，-以及OpenSSL-SSL-read-Connection-was-reset-errno-10054"><a href="#执行Hexo-d报错Spawn-failed，-以及OpenSSL-SSL-read-Connection-was-reset-errno-10054" class="headerlink" title="执行Hexo d报错Spawn failed， 以及OpenSSL SSL_read: Connection was reset, errno 10054"></a><font color="red"><strong>执行Hexo d报错Spawn failed， 以及OpenSSL SSL_read: Connection was reset, errno 10054</strong></font></h2><p>在部署时报了这样的错误，解决方法如下</p><pre class="line-numbers language-shell"><code class="language-shell">ssh git@github.com #首先检测SSH密钥是否有效hexo config deploy.repository git@github.com:GuoYu2022/GuoYu2022.github.io.git # 参考这一句解决hexo config deploy.repository git@github.com:[yourgitname]/[yourgitname].github.io.githexo d #最后就可以deploy了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="对于每次部署新博文到GitHub上时，重定向域名失效问题的解决方法"><a href="#对于每次部署新博文到GitHub上时，重定向域名失效问题的解决方法" class="headerlink" title="对于每次部署新博文到GitHub上时，重定向域名失效问题的解决方法"></a><font color="red"><strong>对于每次部署新博文到GitHub上时，重定向域名失效问题的解决方法</strong></font></h2><p>首先需要确定GitHub仓库根目录下已有CNAME文件，在本地博客根目录文件夹下<strong>source</strong> 文件夹里新建一个CNAME文件（<font color="red"><strong>注意该文件没有后缀名</strong></font>），内容为你的域名<code>flying2the.top</code>（<font color="red"><strong>这里不需要写www或者https</strong></font>），然后hexo g -d</p>]]></content>
      
      
      <categories>
          
          <category> 解决问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
            <tag> 问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/04/hello-world/"/>
      <url>/2022/05/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 解决问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
            <tag> 问题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
